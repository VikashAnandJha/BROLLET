{"version":3,"sources":["crypto-ts.umd.js"],"names":["global","factory","exports","module","define","amd","CryptoTS","this","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__extends","__","constructor","prototype","create","Hex","stringify","wordArray","hexChars","i","sigBytes","bite","words","push","toString","join","parse","hexStr","hexStrLength","length","parseInt","substr","WordArray","undefined","random","nBytes","r","m_w","m_z","mask","result","Math","rcache","_r","encoder","concat","clamp","thatByte","ceil","clone","slice","Latin1","latin1Chars","String","fromCharCode","latin1Str","latin1StrLength","charCodeAt","Utf8","decodeURIComponent","escape","e","Error","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","cfg","_minBufferSize","assign","blockSize","_data","_nDataBytes","reset","_append","data","_process","doFlush","processedWords","blockSizeBytes","nBlocksReady","nWordsReady","max","nBytesReady","min","offset","_doProcessBlock","splice","attr","Base","CipherParams","_super","cipherParams","_this","call","ciphertext","key","iv","salt","algorithm","mode","padding","formatter","extend","additionalParams","Base64","base64Chars","triplet","j","_map","charAt","paddingChar","base64Str","base64StrLength","_reverseMap","paddingIndex","indexOf","parseLoop","reverseMap","bits1","bits2","OpenSSL","openSSLStr","SerializableCipher","encrypt","cipher","message","config","encryptor","createEncryptor","finalize","format","decrypt","optionalCfg","_parse","createDecryptor","Hasher","_createHelper","hasher","update","messageUpdate","_doFinalize","T","abs","sin","MD5","apply","arguments","FF","a","c","x","s","t","n","GG","HH","II","_hash","M","offset_i","M_offset_i","H","M_offset_0","M_offset_1","M_offset_2","M_offset_3","M_offset_4","M_offset_5","M_offset_6","M_offset_7","M_offset_8","M_offset_9","M_offset_10","M_offset_11","M_offset_12","M_offset_13","M_offset_14","M_offset_15","dataWords","nBitsTotal","nBitsLeft","nBitsTotalH","floor","nBitsTotalL","hash","H_i","EvpKDF","keySize","iterations","compute","password","block","derivedKey","OpenSSLKdf","execute","ivSize","PasswordBasedCipher","kdf","derivedParams","Cipher","xformMode","_xformMode","_key","_ENC_XFORM_MODE","_DEC_XFORM_MODE","process","dataUpdate","BlockCipherModeAlgorithm","init","_cipher","_iv","BlockCipherMode","encryptorClass","Encryptor","decryptorClass","Decryptor","CBCEncryptor","processBlock","xorBlock","encryptBlock","_prevBlock","CBCDecryptor","thisBlock","decryptBlock","CBC","PKCS7","pad","nPaddingBytes","paddingWord","paddingWords","unpad","BlockCipher","modeCreator","_mode","__creator","finalProcessedBlocks","SBOX","INV_SBOX","SUB_MIX_0","SUB_MIX_1","SUB_MIX_2","SUB_MIX_3","INV_SUB_MIX_0","INV_SUB_MIX_1","INV_SUB_MIX_2","INV_SUB_MIX_3","xi","sx","x2","x4","x8","RCON","AES","_nRounds","_keyPriorReset","keyWords","ksRows","keySchedule","_keySchedule","ksRow","invKeySchedule","_invKeySchedule","invKsRow","_doCryptBlock","sub_mix_0","sub_mix_1","sub_mix_2","sub_mix_3","sbox","s0","s1","s2","s3","round","t0","t1","t2","t3","t0g","t1g","t2g","t3g","K","W","SHA256","Hl","f","g","h","gamma0x","gamma0","gamma1x","gamma1","maj","sigma0","NoPadding","ECBEncryptor","ECBDecryptor","ECB","lib","algo","enc","AES$1","SHA256$1","ɵl","ɵm","ɵp","ɵo","ɵn","ɵg","ɵa","ɵc","ɵb","ɵf","ɵi","ɵk","ɵj","ɵe","ɵt","ɵs","ɵu","ɵq","ɵr","defineProperty","value"],"mappings":"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","file":"crypto-ts.umd.min.js.map","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define('crypto-ts', ['exports'], factory) :\n    (factory((global.CryptoTS = {})));\n}(this, (function (exports) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\n\n    /**\n     * @license crypto-ts\n     * MIT license\n     */\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var Hex = /** @class */ (function () {\n        function Hex() {\n        }\n        /**\n         * Converts a word array to a hex string.\n         *\n         * \\@example\n         *\n         *     let hexString = Hex.stringify(wordArray);\n         * @param {?} wordArray The word array.\n         *\n         * @return {?} The hex string.\n         *\n         */\n        Hex.stringify = /**\n         * Converts a word array to a hex string.\n         *\n         * \\@example\n         *\n         *     let hexString = Hex.stringify(wordArray);\n         * @param {?} wordArray The word array.\n         *\n         * @return {?} The hex string.\n         *\n         */\n        function (wordArray) {\n            // Convert\n            var /** @type {?} */ hexChars = [];\n            for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i++) {\n                var /** @type {?} */ bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n            return hexChars.join('');\n        };\n        /**\n         * Converts a hex string to a word array.\n         *\n         * \\@example\n         *\n         *     let wordArray = Hex.parse(hexString);\n         * @param {?} hexStr The hex string.\n         *\n         * @return {?} The word array.\n         *\n         */\n        Hex.parse = /**\n         * Converts a hex string to a word array.\n         *\n         * \\@example\n         *\n         *     let wordArray = Hex.parse(hexString);\n         * @param {?} hexStr The hex string.\n         *\n         * @return {?} The word array.\n         *\n         */\n        function (hexStr) {\n            // Shortcut\n            var /** @type {?} */ hexStrLength = hexStr.length;\n            // Convert\n            var /** @type {?} */ words = [];\n            for (var /** @type {?} */ i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n            return new WordArray(words, hexStrLength / 2);\n        };\n        return Hex;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var WordArray = /** @class */ (function () {\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param words (Optional) An array of 32-bit words.\n         * @param sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     let wordArray = new WordArray();\n         *     let wordArray = new WordArray([0x00010203, 0x04050607]);\n         *     let wordArray = new WordArray([0x00010203, 0x04050607], 6);\n         */\n        function WordArray(words, sigBytes) {\n            this.words = words || [];\n            if (sigBytes !== undefined) {\n                this.sigBytes = sigBytes;\n            }\n            else {\n                this.sigBytes = this.words.length * 4;\n            }\n        }\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * \\@example\n         *\n         *     let wordArray = WordArray.random(16);\n         * @param {?} nBytes The number of random bytes to generate.\n         *\n         * @return {?} The random word array.\n         *\n         */\n        WordArray.random = /**\n         * Creates a word array filled with random bytes.\n         *\n         * \\@example\n         *\n         *     let wordArray = WordArray.random(16);\n         * @param {?} nBytes The number of random bytes to generate.\n         *\n         * @return {?} The random word array.\n         *\n         */\n        function (nBytes) {\n            var /** @type {?} */ words = [];\n            var /** @type {?} */ r = (function (m_w) {\n                var /** @type {?} */ m_z = 0x3ade68b1;\n                var /** @type {?} */ mask = 0xffffffff;\n                return function () {\n                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n                    var /** @type {?} */ result = ((m_z << 0x10) + m_w) & mask;\n                    result /= 0x100000000;\n                    result += 0.5;\n                    return result * (Math.random() > .5 ? 1 : -1);\n                };\n            });\n            for (var /** @type {?} */ i = 0, /** @type {?} */ rcache = void 0; i < nBytes; i += 4) {\n                var /** @type {?} */ _r = r((rcache || Math.random()) * 0x100000000);\n                rcache = _r() * 0x3ade67b7;\n                words.push((_r() * 0x100000000) | 0);\n            }\n            return new WordArray(words, nBytes);\n        };\n        /**\n         * Converts this word array to a string.\n         *\n         * @param encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return The stringified word array.\n         *\n         * @example\n         *\n         *     let string = wordArray + '';\n         *     let string = wordArray.toString();\n         *     let string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        /**\n         * Converts this word array to a string.\n         *\n         * \\@example\n         *\n         *     let string = wordArray + '';\n         *     let string = wordArray.toString();\n         *     let string = wordArray.toString(CryptoJS.enc.Utf8);\n         * @param {?=} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {?} The stringified word array.\n         *\n         */\n        WordArray.prototype.toString = /**\n         * Converts this word array to a string.\n         *\n         * \\@example\n         *\n         *     let string = wordArray + '';\n         *     let string = wordArray.toString();\n         *     let string = wordArray.toString(CryptoJS.enc.Utf8);\n         * @param {?=} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {?} The stringified word array.\n         *\n         */\n        function (encoder) {\n            return (encoder || Hex).stringify(this);\n        };\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param wordArray The word array to append.\n         *\n         * @return This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * \\@example\n         *\n         *     wordArray1.concat(wordArray2);\n         * @param {?} wordArray The word array to append.\n         *\n         * @return {?} This word array.\n         *\n         */\n        WordArray.prototype.concat = /**\n         * Concatenates a word array to this word array.\n         *\n         * \\@example\n         *\n         *     wordArray1.concat(wordArray2);\n         * @param {?} wordArray The word array to append.\n         *\n         * @return {?} This word array.\n         *\n         */\n        function (wordArray) {\n            // Clamp excess bits\n            this.clamp();\n            // Concat\n            if (this.sigBytes % 4) {\n                // Copy one byte at a time\n                for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i++) {\n                    var /** @type {?} */ thatByte = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    this.words[(this.sigBytes + i) >>> 2] |= thatByte << (24 - ((this.sigBytes + i) % 4) * 8);\n                }\n            }\n            else {\n                // Copy one word at a time\n                for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i += 4) {\n                    this.words[(this.sigBytes + i) >>> 2] = wordArray.words[i >>> 2];\n                }\n            }\n            this.sigBytes += wordArray.sigBytes;\n            // Chainable\n            return this;\n        };\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        /**\n         * Removes insignificant bits.\n         *\n         * \\@example\n         *\n         *     wordArray.clamp();\n         * @return {?}\n         */\n        WordArray.prototype.clamp = /**\n         * Removes insignificant bits.\n         *\n         * \\@example\n         *\n         *     wordArray.clamp();\n         * @return {?}\n         */\n        function () {\n            // Clamp\n            this.words[this.sigBytes >>> 2] &= 0xffffffff << (32 - (this.sigBytes % 4) * 8);\n            this.words.length = Math.ceil(this.sigBytes / 4);\n        };\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return The clone.\n         *\n         * @example\n         *\n         *     let clone = wordArray.clone();\n         */\n        /**\n         * Creates a copy of this word array.\n         *\n         * \\@example\n         *\n         *     let clone = wordArray.clone();\n         * @return {?} The clone.\n         *\n         */\n        WordArray.prototype.clone = /**\n         * Creates a copy of this word array.\n         *\n         * \\@example\n         *\n         *     let clone = wordArray.clone();\n         * @return {?} The clone.\n         *\n         */\n        function () {\n            return new WordArray(this.words.slice(0), this.sigBytes);\n        };\n        return WordArray;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var Latin1 = /** @class */ (function () {\n        function Latin1() {\n        }\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * \\@example\n         *\n         *     let latin1String = Latin1.stringify(wordArray);\n         * @param {?} wordArray The word array.\n         *\n         * @return {?} The Latin1 string.\n         *\n         */\n        Latin1.stringify = /**\n         * Converts a word array to a Latin1 string.\n         *\n         * \\@example\n         *\n         *     let latin1String = Latin1.stringify(wordArray);\n         * @param {?} wordArray The word array.\n         *\n         * @return {?} The Latin1 string.\n         *\n         */\n        function (wordArray) {\n            // Convert\n            var /** @type {?} */ latin1Chars = [];\n            for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i++) {\n                var /** @type {?} */ bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n            return latin1Chars.join('');\n        };\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * \\@example\n         *\n         *     let wordArray = Latin1.parse(latin1String);\n         * @param {?} latin1Str The Latin1 string.\n         *\n         * @return {?} The word array.\n         *\n         */\n        Latin1.parse = /**\n         * Converts a Latin1 string to a word array.\n         *\n         * \\@example\n         *\n         *     let wordArray = Latin1.parse(latin1String);\n         * @param {?} latin1Str The Latin1 string.\n         *\n         * @return {?} The word array.\n         *\n         */\n        function (latin1Str) {\n            // Shortcut\n            var /** @type {?} */ latin1StrLength = latin1Str.length;\n            // Convert\n            var /** @type {?} */ words = [];\n            for (var /** @type {?} */ i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n            return new WordArray(words, latin1StrLength);\n        };\n        return Latin1;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var Utf8 = /** @class */ (function () {\n        function Utf8() {\n        }\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * \\@example\n         *\n         *     let utf8String = Utf8.stringify(wordArray);\n         * @param {?} wordArray The word array.\n         *\n         * @return {?} The UTF-8 string.\n         *\n         */\n        Utf8.stringify = /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * \\@example\n         *\n         *     let utf8String = Utf8.stringify(wordArray);\n         * @param {?} wordArray The word array.\n         *\n         * @return {?} The UTF-8 string.\n         *\n         */\n        function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            }\n            catch (/** @type {?} */ e) {\n                throw new Error('Malformed UTF-8 data');\n            }\n        };\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * \\@example\n         *\n         *     let wordArray = Utf8.parse(utf8String);\n         * @param {?} utf8Str The UTF-8 string.\n         *\n         * @return {?} The word array.\n         *\n         */\n        Utf8.parse = /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * \\@example\n         *\n         *     let wordArray = Utf8.parse(utf8String);\n         * @param {?} utf8Str The UTF-8 string.\n         *\n         * @return {?} The word array.\n         *\n         */\n        function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        };\n        return Utf8;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * @abstract\n     */\n    var   /**\n     * @abstract\n     */\n    BufferedBlockAlgorithm = /** @class */ (function () {\n        function BufferedBlockAlgorithm(cfg) {\n            this._minBufferSize = 0;\n            this.cfg = Object.assign({\n                blockSize: 1\n            }, cfg);\n            // Initial values\n            this._data = new WordArray();\n            this._nDataBytes = 0;\n        }\n        /**\n         * Resets this block algorithm's data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        /**\n         * Resets this block algorithm's data buffer to its initial state.\n         *\n         * \\@example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         * @return {?}\n         */\n        BufferedBlockAlgorithm.prototype.reset = /**\n         * Resets this block algorithm's data buffer to its initial state.\n         *\n         * \\@example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         * @return {?}\n         */\n        function () {\n            // Initial values\n            this._data = new WordArray();\n            this._nDataBytes = 0;\n        };\n        /**\n         * Adds new data to this block algorithm's buffer.\n         *\n         * @param data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append('data');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        /**\n         * Adds new data to this block algorithm's buffer.\n         *\n         * \\@example\n         *\n         *     bufferedBlockAlgorithm._append('data');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         * @param {?} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @return {?}\n         */\n        BufferedBlockAlgorithm.prototype._append = /**\n         * Adds new data to this block algorithm's buffer.\n         *\n         * \\@example\n         *\n         *     bufferedBlockAlgorithm._append('data');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         * @param {?} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @return {?}\n         */\n        function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data === 'string') {\n                data = Utf8.parse(data);\n            }\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        };\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return The processed data.\n         *\n         * @example\n         *\n         *     let processedData = bufferedBlockAlgorithm._process();\n         *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\n         */\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * \\@example\n         *\n         *     let processedData = bufferedBlockAlgorithm._process();\n         *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\n         * @param {?=} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {?} The processed data.\n         *\n         */\n        BufferedBlockAlgorithm.prototype._process = /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * \\@example\n         *\n         *     let processedData = bufferedBlockAlgorithm._process();\n         *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\n         * @param {?=} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {?} The processed data.\n         *\n         */\n        function (doFlush) {\n            if (!this.cfg.blockSize) {\n                throw new Error('missing blockSize in config');\n            }\n            // Shortcuts\n            var /** @type {?} */ blockSizeBytes = this.cfg.blockSize * 4;\n            // Count blocks ready\n            var /** @type {?} */ nBlocksReady = this._data.sigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            }\n            else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n            // Count words ready\n            var /** @type {?} */ nWordsReady = nBlocksReady * this.cfg.blockSize;\n            // Count bytes ready\n            var /** @type {?} */ nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n            // Process blocks\n            var /** @type {?} */ processedWords;\n            if (nWordsReady) {\n                for (var /** @type {?} */ offset = 0; offset < nWordsReady; offset += this.cfg.blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(this._data.words, offset);\n                }\n                // Remove processed words\n                processedWords = this._data.words.splice(0, nWordsReady);\n                this._data.sigBytes -= nBytesReady;\n            }\n            // Return processed words\n            return new WordArray(processedWords, nBytesReady);\n        };\n        /**\n         * Creates a copy of this object.\n         *\n         * @return The clone.\n         *\n         * @example\n         *\n         *     let clone = bufferedBlockAlgorithm.clone();\n         */\n        /**\n         * Creates a copy of this object.\n         *\n         * \\@example\n         *\n         *     let clone = bufferedBlockAlgorithm.clone();\n         * @return {?} The clone.\n         *\n         */\n        BufferedBlockAlgorithm.prototype.clone = /**\n         * Creates a copy of this object.\n         *\n         * \\@example\n         *\n         *     let clone = bufferedBlockAlgorithm.clone();\n         * @return {?} The clone.\n         *\n         */\n        function () {\n            var /** @type {?} */ clone = this.constructor();\n            for (var /** @type {?} */ attr in this) {\n                if (this.hasOwnProperty(attr)) {\n                    clone[attr] = this[attr];\n                }\n            }\n            clone._data = this._data.clone();\n            return clone;\n        };\n        return BufferedBlockAlgorithm;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var Base = /** @class */ (function () {\n        function Base() {\n        }\n        return Base;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var CipherParams = /** @class */ (function (_super) {\n        __extends(CipherParams, _super);\n        function CipherParams(cipherParams) {\n            var _this = _super.call(this) || this;\n            _this.ciphertext = cipherParams.ciphertext;\n            _this.key = cipherParams.key;\n            _this.iv = cipherParams.iv;\n            _this.salt = cipherParams.salt;\n            _this.algorithm = cipherParams.algorithm;\n            _this.mode = cipherParams.mode;\n            _this.padding = cipherParams.padding;\n            _this.blockSize = cipherParams.blockSize;\n            _this.formatter = cipherParams.formatter;\n            return _this;\n        }\n        /**\n         * @param {?} additionalParams\n         * @return {?}\n         */\n        CipherParams.prototype.extend = /**\n         * @param {?} additionalParams\n         * @return {?}\n         */\n        function (additionalParams) {\n            if (additionalParams.ciphertext !== undefined) {\n                this.ciphertext = additionalParams.ciphertext;\n            }\n            if (additionalParams.key !== undefined) {\n                this.key = additionalParams.key;\n            }\n            if (additionalParams.iv !== undefined) {\n                this.iv = additionalParams.iv;\n            }\n            if (additionalParams.salt !== undefined) {\n                this.salt = additionalParams.salt;\n            }\n            if (additionalParams.algorithm !== undefined) {\n                this.algorithm = additionalParams.algorithm;\n            }\n            if (additionalParams.mode !== undefined) {\n                this.mode = additionalParams.mode;\n            }\n            if (additionalParams.padding !== undefined) {\n                this.padding = additionalParams.padding;\n            }\n            if (additionalParams.blockSize !== undefined) {\n                this.blockSize = additionalParams.blockSize;\n            }\n            if (additionalParams.formatter !== undefined) {\n                this.formatter = additionalParams.formatter;\n            }\n            return this;\n        };\n        /**\n         * Converts this cipher params object to a string.\n         *\n         * @throws Error If neither the formatter nor the default formatter is set.\n         *\n         * \\@example\n         *\n         *     let string = cipherParams + '';\n         *     let string = cipherParams.toString();\n         *     let string = cipherParams.toString(CryptoJS.format.OpenSSL);\n         * @param {?=} formatter (Optional) The formatting strategy to use.\n         *\n         * @return {?} The stringified cipher params.\n         *\n         */\n        CipherParams.prototype.toString = /**\n         * Converts this cipher params object to a string.\n         *\n         * @throws Error If neither the formatter nor the default formatter is set.\n         *\n         * \\@example\n         *\n         *     let string = cipherParams + '';\n         *     let string = cipherParams.toString();\n         *     let string = cipherParams.toString(CryptoJS.format.OpenSSL);\n         * @param {?=} formatter (Optional) The formatting strategy to use.\n         *\n         * @return {?} The stringified cipher params.\n         *\n         */\n        function (formatter) {\n            if (formatter) {\n                return formatter.stringify(this);\n            }\n            else if (this.formatter) {\n                return this.formatter.stringify(this);\n            }\n            else {\n                throw new Error('cipher needs a formatter to be able to convert the result into a string');\n            }\n        };\n        return CipherParams;\n    }(Base));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var Base64 = /** @class */ (function () {\n        function Base64() {\n        }\n        /**\n         * Converts a word array to a Base64 string.\n         *\n         * \\@example\n         *\n         *     let base64String = Base64.stringify(wordArray);\n         * @param {?} wordArray The word array.\n         *\n         * @return {?} The Base64 string.\n         *\n         */\n        Base64.stringify = /**\n         * Converts a word array to a Base64 string.\n         *\n         * \\@example\n         *\n         *     let base64String = Base64.stringify(wordArray);\n         * @param {?} wordArray The word array.\n         *\n         * @return {?} The Base64 string.\n         *\n         */\n        function (wordArray) {\n            // Clamp excess bits\n            wordArray.clamp();\n            // Convert\n            var /** @type {?} */ base64Chars = [];\n            for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i += 3) {\n                var /** @type {?} */ byte1 = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                var /** @type {?} */ byte2 = (wordArray.words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n                var /** @type {?} */ byte3 = (wordArray.words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n                var /** @type {?} */ triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n                for (var /** @type {?} */ j = 0; (j < 4) && (i + j * 0.75 < wordArray.sigBytes); j++) {\n                    base64Chars.push(this._map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n                }\n            }\n            // Add padding\n            var /** @type {?} */ paddingChar = this._map.charAt(64);\n            if (paddingChar) {\n                while (base64Chars.length % 4) {\n                    base64Chars.push(paddingChar);\n                }\n            }\n            return base64Chars.join('');\n        };\n        /**\n         * Converts a Base64 string to a word array.\n         *\n         * \\@example\n         *\n         *     let wordArray = Base64.parse(base64String);\n         * @param {?} base64Str The Base64 string.\n         *\n         * @return {?} The word array.\n         *\n         */\n        Base64.parse = /**\n         * Converts a Base64 string to a word array.\n         *\n         * \\@example\n         *\n         *     let wordArray = Base64.parse(base64String);\n         * @param {?} base64Str The Base64 string.\n         *\n         * @return {?} The word array.\n         *\n         */\n        function (base64Str) {\n            // Shortcuts\n            var /** @type {?} */ base64StrLength = base64Str.length;\n            if (this._reverseMap === undefined) {\n                this._reverseMap = [];\n                for (var /** @type {?} */ j = 0; j < this._map.length; j++) {\n                    this._reverseMap[this._map.charCodeAt(j)] = j;\n                }\n            }\n            // Ignore padding\n            var /** @type {?} */ paddingChar = this._map.charAt(64);\n            if (paddingChar) {\n                var /** @type {?} */ paddingIndex = base64Str.indexOf(paddingChar);\n                if (paddingIndex !== -1) {\n                    base64StrLength = paddingIndex;\n                }\n            }\n            // Convert\n            return this.parseLoop(base64Str, base64StrLength, this._reverseMap);\n        };\n        /**\n         * @param {?} base64Str\n         * @param {?} base64StrLength\n         * @param {?} reverseMap\n         * @return {?}\n         */\n        Base64.parseLoop = /**\n         * @param {?} base64Str\n         * @param {?} base64StrLength\n         * @param {?} reverseMap\n         * @return {?}\n         */\n        function (base64Str, base64StrLength, reverseMap) {\n            var /** @type {?} */ words = [];\n            var /** @type {?} */ nBytes = 0;\n            for (var /** @type {?} */ i = 0; i < base64StrLength; i++) {\n                if (i % 4) {\n                    var /** @type {?} */ bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n                    var /** @type {?} */ bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);\n                    nBytes++;\n                }\n            }\n            return new WordArray(words, nBytes);\n        };\n        Base64._map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        Base64._reverseMap = undefined;\n        return Base64;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var OpenSSL = /** @class */ (function () {\n        function OpenSSL() {\n        }\n        /**\n         * Converts a cipher params object to an OpenSSL-compatible string.\n         *\n         * \\@example\n         *\n         *     let openSSLString = OpenSSLFormatter.stringify(cipherParams);\n         * @param {?} cipherParams The cipher params object.\n         *\n         * @return {?} The OpenSSL-compatible string.\n         *\n         */\n        OpenSSL.stringify = /**\n         * Converts a cipher params object to an OpenSSL-compatible string.\n         *\n         * \\@example\n         *\n         *     let openSSLString = OpenSSLFormatter.stringify(cipherParams);\n         * @param {?} cipherParams The cipher params object.\n         *\n         * @return {?} The OpenSSL-compatible string.\n         *\n         */\n        function (cipherParams) {\n            if (!cipherParams.ciphertext) {\n                throw new Error('missing ciphertext in params');\n            }\n            // Shortcuts\n            var /** @type {?} */ ciphertext = cipherParams.ciphertext;\n            var /** @type {?} */ salt = cipherParams.salt;\n            // Format\n            var /** @type {?} */ wordArray;\n            if (salt) {\n                if (typeof salt === 'string') {\n                    throw new Error('salt is expected to be a WordArray');\n                }\n                wordArray = (new WordArray([0x53616c74, 0x65645f5f])).concat(salt).concat(ciphertext);\n            }\n            else {\n                wordArray = ciphertext;\n            }\n            return wordArray.toString(Base64);\n        };\n        /**\n         * Converts an OpenSSL-compatible string to a cipher params object.\n         *\n         * \\@example\n         *\n         *     let cipherParams = OpenSSLFormatter.parse(openSSLString);\n         * @param {?} openSSLStr The OpenSSL-compatible string.\n         *\n         * @return {?} The cipher params object.\n         *\n         */\n        OpenSSL.parse = /**\n         * Converts an OpenSSL-compatible string to a cipher params object.\n         *\n         * \\@example\n         *\n         *     let cipherParams = OpenSSLFormatter.parse(openSSLString);\n         * @param {?} openSSLStr The OpenSSL-compatible string.\n         *\n         * @return {?} The cipher params object.\n         *\n         */\n        function (openSSLStr) {\n            // Parse base64\n            var /** @type {?} */ ciphertext = Base64.parse(openSSLStr);\n            // Test for salt\n            var /** @type {?} */ salt;\n            if (ciphertext.words[0] === 0x53616c74 && ciphertext.words[1] === 0x65645f5f) {\n                // Extract salt\n                salt = new WordArray(ciphertext.words.slice(2, 4));\n                // Remove salt from ciphertext\n                ciphertext.words.splice(0, 4);\n                ciphertext.sigBytes -= 16;\n            }\n            return new CipherParams({ ciphertext: ciphertext, salt: salt });\n        };\n        return OpenSSL;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var SerializableCipher = /** @class */ (function () {\n        function SerializableCipher() {\n        }\n        /**\n         * Encrypts a message.\n         *\n         * \\@example\n         *\n         *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n         *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n         *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, {\n         *       iv: iv,\n         *       format: CryptoJS.format.OpenSSL\n         *     });\n         * @param {?} cipher The cipher algorithm to use.\n         * @param {?} message The message to encrypt.\n         * @param {?} key The key.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} A cipher params object.\n         *\n         */\n        SerializableCipher.encrypt = /**\n         * Encrypts a message.\n         *\n         * \\@example\n         *\n         *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n         *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n         *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, {\n         *       iv: iv,\n         *       format: CryptoJS.format.OpenSSL\n         *     });\n         * @param {?} cipher The cipher algorithm to use.\n         * @param {?} message The message to encrypt.\n         * @param {?} key The key.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} A cipher params object.\n         *\n         */\n        function (cipher, message, key, cfg) {\n            // Apply config defaults\n            var /** @type {?} */ config = Object.assign({}, this.cfg, cfg);\n            // Encrypt\n            var /** @type {?} */ encryptor = cipher.createEncryptor(key, config);\n            var /** @type {?} */ ciphertext = encryptor.finalize(message);\n            // Create and return serializable cipher params\n            return new CipherParams({\n                ciphertext: ciphertext,\n                key: key,\n                iv: encryptor.cfg.iv,\n                algorithm: cipher,\n                mode: (/** @type {?} */ (encryptor.cfg)).mode,\n                padding: (/** @type {?} */ (encryptor.cfg)).padding,\n                blockSize: encryptor.cfg.blockSize,\n                formatter: config.format\n            });\n        };\n        /**\n         * Decrypts serialized ciphertext.\n         *\n         * \\@example\n         *\n         *     let plaintext = SerializableCipher.decrypt(\n         *         AESAlgorithm,\n         *         formattedCiphertext,\n         *         key, {\n         *             iv: iv,\n         *             format: CryptoJS.format.OpenSSL\n         *         }\n         *     );\n         *\n         *     let plaintext = SerializableCipher.decrypt(\n         *         AESAlgorithm,\n         *         ciphertextParams,\n         *         key, {\n         *             iv: iv,\n         *             format: CryptoJS.format.OpenSSL\n         *         }\n         *     );\n         * @param {?} cipher The cipher algorithm to use.\n         * @param {?} ciphertext The ciphertext to decrypt.\n         * @param {?} key The key.\n         * @param {?=} optionalCfg\n         * @return {?} The plaintext.\n         *\n         */\n        SerializableCipher.decrypt = /**\n         * Decrypts serialized ciphertext.\n         *\n         * \\@example\n         *\n         *     let plaintext = SerializableCipher.decrypt(\n         *         AESAlgorithm,\n         *         formattedCiphertext,\n         *         key, {\n         *             iv: iv,\n         *             format: CryptoJS.format.OpenSSL\n         *         }\n         *     );\n         *\n         *     let plaintext = SerializableCipher.decrypt(\n         *         AESAlgorithm,\n         *         ciphertextParams,\n         *         key, {\n         *             iv: iv,\n         *             format: CryptoJS.format.OpenSSL\n         *         }\n         *     );\n         * @param {?} cipher The cipher algorithm to use.\n         * @param {?} ciphertext The ciphertext to decrypt.\n         * @param {?} key The key.\n         * @param {?=} optionalCfg\n         * @return {?} The plaintext.\n         *\n         */\n        function (cipher, ciphertext, key, optionalCfg) {\n            // Apply config defaults\n            var /** @type {?} */ cfg = Object.assign({}, this.cfg, optionalCfg);\n            if (!cfg.format) {\n                throw new Error('could not determine format');\n            }\n            // Convert string to CipherParams\n            ciphertext = this._parse(ciphertext, cfg.format);\n            if (!ciphertext.ciphertext) {\n                throw new Error('could not determine ciphertext');\n            }\n            // Decrypt\n            var /** @type {?} */ plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n            return plaintext;\n        };\n        /**\n         * Converts serialized ciphertext to CipherParams,\n         * else assumed CipherParams already and returns ciphertext unchanged.\n         *\n         * \\@example\n         *\n         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n         * @param {?} ciphertext The ciphertext.\n         * @param {?} format The formatting strategy to use to parse serialized ciphertext.\n         *\n         * @return {?} The unserialized ciphertext.\n         *\n         */\n        SerializableCipher._parse = /**\n         * Converts serialized ciphertext to CipherParams,\n         * else assumed CipherParams already and returns ciphertext unchanged.\n         *\n         * \\@example\n         *\n         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n         * @param {?} ciphertext The ciphertext.\n         * @param {?} format The formatting strategy to use to parse serialized ciphertext.\n         *\n         * @return {?} The unserialized ciphertext.\n         *\n         */\n        function (ciphertext, format) {\n            if (typeof ciphertext === 'string') {\n                return format.parse(ciphertext);\n            }\n            else {\n                return ciphertext;\n            }\n        };\n        SerializableCipher.cfg = {\n            blockSize: 4,\n            iv: new WordArray([]),\n            format: OpenSSL\n        };\n        return SerializableCipher;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * @abstract\n     */\n    var   /**\n     * @abstract\n     */\n    Hasher = /** @class */ (function (_super) {\n        __extends(Hasher, _super);\n        function Hasher(cfg) {\n            var _this = \n            // Apply config defaults\n            _super.call(this, Object.assign({\n                blockSize: 512 / 32\n            }, cfg)) || this;\n            // Set initial values\n            // Set initial values\n            _this.reset();\n            return _this;\n        }\n        /**\n         * Creates a shortcut function to a hasher's object interface.\n         *\n         * \\@example\n         *\n         *     let SHA256 = Hasher._createHelper(SHA256);\n         * @param {?} hasher The hasher to create a helper for.\n         *\n         * @return {?} The shortcut function.\n         *\n         */\n        Hasher._createHelper = /**\n         * Creates a shortcut function to a hasher's object interface.\n         *\n         * \\@example\n         *\n         *     let SHA256 = Hasher._createHelper(SHA256);\n         * @param {?} hasher The hasher to create a helper for.\n         *\n         * @return {?} The shortcut function.\n         *\n         */\n        function (hasher) {\n            /**\n             * @param {?} message\n             * @param {?=} cfg\n             * @return {?}\n             */\n            function helper(message, cfg) {\n                var /** @type {?} */ hasherClass = hasher;\n                var /** @type {?} */ hasherInstance = new hasherClass(cfg);\n                return hasherInstance.finalize(message);\n            }\n            return helper;\n        };\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param messageUpdate The message to append.\n         *\n         * @return This hasher.\n         *\n         * @example\n         *\n         *     hasher.update('message');\n         *     hasher.update(wordArray);\n         */\n        /**\n         * Updates this hasher with a message.\n         *\n         * \\@example\n         *\n         *     hasher.update('message');\n         *     hasher.update(wordArray);\n         * @param {?} messageUpdate The message to append.\n         *\n         * @return {?} This hasher.\n         *\n         */\n        Hasher.prototype.update = /**\n         * Updates this hasher with a message.\n         *\n         * \\@example\n         *\n         *     hasher.update('message');\n         *     hasher.update(wordArray);\n         * @param {?} messageUpdate The message to append.\n         *\n         * @return {?} This hasher.\n         *\n         */\n        function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n            // Update the hash\n            this._process();\n            // Chainable\n            return this;\n        };\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * \\@example\n         *\n         *     let hash = hasher.finalize();\n         *     let hash = hasher.finalize('message');\n         *     let hash = hasher.finalize(wordArray);\n         * @param {?} messageUpdate (Optional) A final message update.\n         *\n         * @return {?} The hash.\n         *\n         */\n        Hasher.prototype.finalize = /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * \\@example\n         *\n         *     let hash = hasher.finalize();\n         *     let hash = hasher.finalize('message');\n         *     let hash = hasher.finalize(wordArray);\n         * @param {?} messageUpdate (Optional) A final message update.\n         *\n         * @return {?} The hash.\n         *\n         */\n        function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n            // Perform concrete-hasher logic\n            var /** @type {?} */ hash = this._doFinalize();\n            return hash;\n        };\n        return Hasher;\n    }(BufferedBlockAlgorithm));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    // Constants table\n    var /** @type {?} */ T = [];\n    // Compute constants\n    for (var /** @type {?} */ i = 0; i < 64; i++) {\n        T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n    }\n    var MD5 = /** @class */ (function (_super) {\n        __extends(MD5, _super);\n        function MD5() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * @param {?} a\n         * @param {?} b\n         * @param {?} c\n         * @param {?} d\n         * @param {?} x\n         * @param {?} s\n         * @param {?} t\n         * @return {?}\n         */\n        MD5.FF = /**\n         * @param {?} a\n         * @param {?} b\n         * @param {?} c\n         * @param {?} d\n         * @param {?} x\n         * @param {?} s\n         * @param {?} t\n         * @return {?}\n         */\n        function (a, b, c, d, x, s, t) {\n            var /** @type {?} */ n = a + ((b & c) | (~b & d)) + x + t;\n            return ((n << s) | (n >>> (32 - s))) + b;\n        };\n        /**\n         * @param {?} a\n         * @param {?} b\n         * @param {?} c\n         * @param {?} d\n         * @param {?} x\n         * @param {?} s\n         * @param {?} t\n         * @return {?}\n         */\n        MD5.GG = /**\n         * @param {?} a\n         * @param {?} b\n         * @param {?} c\n         * @param {?} d\n         * @param {?} x\n         * @param {?} s\n         * @param {?} t\n         * @return {?}\n         */\n        function (a, b, c, d, x, s, t) {\n            var /** @type {?} */ n = a + ((b & d) | (c & ~d)) + x + t;\n            return ((n << s) | (n >>> (32 - s))) + b;\n        };\n        /**\n         * @param {?} a\n         * @param {?} b\n         * @param {?} c\n         * @param {?} d\n         * @param {?} x\n         * @param {?} s\n         * @param {?} t\n         * @return {?}\n         */\n        MD5.HH = /**\n         * @param {?} a\n         * @param {?} b\n         * @param {?} c\n         * @param {?} d\n         * @param {?} x\n         * @param {?} s\n         * @param {?} t\n         * @return {?}\n         */\n        function (a, b, c, d, x, s, t) {\n            var /** @type {?} */ n = a + (b ^ c ^ d) + x + t;\n            return ((n << s) | (n >>> (32 - s))) + b;\n        };\n        /**\n         * @param {?} a\n         * @param {?} b\n         * @param {?} c\n         * @param {?} d\n         * @param {?} x\n         * @param {?} s\n         * @param {?} t\n         * @return {?}\n         */\n        MD5.II = /**\n         * @param {?} a\n         * @param {?} b\n         * @param {?} c\n         * @param {?} d\n         * @param {?} x\n         * @param {?} s\n         * @param {?} t\n         * @return {?}\n         */\n        function (a, b, c, d, x, s, t) {\n            var /** @type {?} */ n = a + (c ^ (b | ~d)) + x + t;\n            return ((n << s) | (n >>> (32 - s))) + b;\n        };\n        /**\n         * @return {?}\n         */\n        MD5.prototype.reset = /**\n         * @return {?}\n         */\n        function () {\n            // reset core values\n            _super.prototype.reset.call(this);\n            this._hash = new WordArray([\n                0x67452301, 0xefcdab89,\n                0x98badcfe, 0x10325476\n            ]);\n        };\n        /**\n         * @param {?} M\n         * @param {?} offset\n         * @return {?}\n         */\n        MD5.prototype._doProcessBlock = /**\n         * @param {?} M\n         * @param {?} offset\n         * @return {?}\n         */\n        function (M, offset) {\n            // Swap endian\n            for (var /** @type {?} */ i = 0; i < 16; i++) {\n                // Shortcuts\n                var /** @type {?} */ offset_i = offset + i;\n                var /** @type {?} */ M_offset_i = M[offset_i];\n                M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |\n                    (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));\n            }\n            // Shortcuts\n            var /** @type {?} */ H = this._hash.words;\n            var /** @type {?} */ M_offset_0 = M[offset + 0];\n            var /** @type {?} */ M_offset_1 = M[offset + 1];\n            var /** @type {?} */ M_offset_2 = M[offset + 2];\n            var /** @type {?} */ M_offset_3 = M[offset + 3];\n            var /** @type {?} */ M_offset_4 = M[offset + 4];\n            var /** @type {?} */ M_offset_5 = M[offset + 5];\n            var /** @type {?} */ M_offset_6 = M[offset + 6];\n            var /** @type {?} */ M_offset_7 = M[offset + 7];\n            var /** @type {?} */ M_offset_8 = M[offset + 8];\n            var /** @type {?} */ M_offset_9 = M[offset + 9];\n            var /** @type {?} */ M_offset_10 = M[offset + 10];\n            var /** @type {?} */ M_offset_11 = M[offset + 11];\n            var /** @type {?} */ M_offset_12 = M[offset + 12];\n            var /** @type {?} */ M_offset_13 = M[offset + 13];\n            var /** @type {?} */ M_offset_14 = M[offset + 14];\n            var /** @type {?} */ M_offset_15 = M[offset + 15];\n            // Working variables\n            var /** @type {?} */ a = H[0];\n            var /** @type {?} */ b = H[1];\n            var /** @type {?} */ c = H[2];\n            var /** @type {?} */ d = H[3];\n            // Computation\n            a = MD5.FF(a, b, c, d, M_offset_0, 7, T[0]);\n            d = MD5.FF(d, a, b, c, M_offset_1, 12, T[1]);\n            c = MD5.FF(c, d, a, b, M_offset_2, 17, T[2]);\n            b = MD5.FF(b, c, d, a, M_offset_3, 22, T[3]);\n            a = MD5.FF(a, b, c, d, M_offset_4, 7, T[4]);\n            d = MD5.FF(d, a, b, c, M_offset_5, 12, T[5]);\n            c = MD5.FF(c, d, a, b, M_offset_6, 17, T[6]);\n            b = MD5.FF(b, c, d, a, M_offset_7, 22, T[7]);\n            a = MD5.FF(a, b, c, d, M_offset_8, 7, T[8]);\n            d = MD5.FF(d, a, b, c, M_offset_9, 12, T[9]);\n            c = MD5.FF(c, d, a, b, M_offset_10, 17, T[10]);\n            b = MD5.FF(b, c, d, a, M_offset_11, 22, T[11]);\n            a = MD5.FF(a, b, c, d, M_offset_12, 7, T[12]);\n            d = MD5.FF(d, a, b, c, M_offset_13, 12, T[13]);\n            c = MD5.FF(c, d, a, b, M_offset_14, 17, T[14]);\n            b = MD5.FF(b, c, d, a, M_offset_15, 22, T[15]);\n            a = MD5.GG(a, b, c, d, M_offset_1, 5, T[16]);\n            d = MD5.GG(d, a, b, c, M_offset_6, 9, T[17]);\n            c = MD5.GG(c, d, a, b, M_offset_11, 14, T[18]);\n            b = MD5.GG(b, c, d, a, M_offset_0, 20, T[19]);\n            a = MD5.GG(a, b, c, d, M_offset_5, 5, T[20]);\n            d = MD5.GG(d, a, b, c, M_offset_10, 9, T[21]);\n            c = MD5.GG(c, d, a, b, M_offset_15, 14, T[22]);\n            b = MD5.GG(b, c, d, a, M_offset_4, 20, T[23]);\n            a = MD5.GG(a, b, c, d, M_offset_9, 5, T[24]);\n            d = MD5.GG(d, a, b, c, M_offset_14, 9, T[25]);\n            c = MD5.GG(c, d, a, b, M_offset_3, 14, T[26]);\n            b = MD5.GG(b, c, d, a, M_offset_8, 20, T[27]);\n            a = MD5.GG(a, b, c, d, M_offset_13, 5, T[28]);\n            d = MD5.GG(d, a, b, c, M_offset_2, 9, T[29]);\n            c = MD5.GG(c, d, a, b, M_offset_7, 14, T[30]);\n            b = MD5.GG(b, c, d, a, M_offset_12, 20, T[31]);\n            a = MD5.HH(a, b, c, d, M_offset_5, 4, T[32]);\n            d = MD5.HH(d, a, b, c, M_offset_8, 11, T[33]);\n            c = MD5.HH(c, d, a, b, M_offset_11, 16, T[34]);\n            b = MD5.HH(b, c, d, a, M_offset_14, 23, T[35]);\n            a = MD5.HH(a, b, c, d, M_offset_1, 4, T[36]);\n            d = MD5.HH(d, a, b, c, M_offset_4, 11, T[37]);\n            c = MD5.HH(c, d, a, b, M_offset_7, 16, T[38]);\n            b = MD5.HH(b, c, d, a, M_offset_10, 23, T[39]);\n            a = MD5.HH(a, b, c, d, M_offset_13, 4, T[40]);\n            d = MD5.HH(d, a, b, c, M_offset_0, 11, T[41]);\n            c = MD5.HH(c, d, a, b, M_offset_3, 16, T[42]);\n            b = MD5.HH(b, c, d, a, M_offset_6, 23, T[43]);\n            a = MD5.HH(a, b, c, d, M_offset_9, 4, T[44]);\n            d = MD5.HH(d, a, b, c, M_offset_12, 11, T[45]);\n            c = MD5.HH(c, d, a, b, M_offset_15, 16, T[46]);\n            b = MD5.HH(b, c, d, a, M_offset_2, 23, T[47]);\n            a = MD5.II(a, b, c, d, M_offset_0, 6, T[48]);\n            d = MD5.II(d, a, b, c, M_offset_7, 10, T[49]);\n            c = MD5.II(c, d, a, b, M_offset_14, 15, T[50]);\n            b = MD5.II(b, c, d, a, M_offset_5, 21, T[51]);\n            a = MD5.II(a, b, c, d, M_offset_12, 6, T[52]);\n            d = MD5.II(d, a, b, c, M_offset_3, 10, T[53]);\n            c = MD5.II(c, d, a, b, M_offset_10, 15, T[54]);\n            b = MD5.II(b, c, d, a, M_offset_1, 21, T[55]);\n            a = MD5.II(a, b, c, d, M_offset_8, 6, T[56]);\n            d = MD5.II(d, a, b, c, M_offset_15, 10, T[57]);\n            c = MD5.II(c, d, a, b, M_offset_6, 15, T[58]);\n            b = MD5.II(b, c, d, a, M_offset_13, 21, T[59]);\n            a = MD5.II(a, b, c, d, M_offset_4, 6, T[60]);\n            d = MD5.II(d, a, b, c, M_offset_11, 10, T[61]);\n            c = MD5.II(c, d, a, b, M_offset_2, 15, T[62]);\n            b = MD5.II(b, c, d, a, M_offset_9, 21, T[63]);\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n        };\n        /**\n         * @return {?}\n         */\n        MD5.prototype._doFinalize = /**\n         * @return {?}\n         */\n        function () {\n            // Shortcuts\n            var /** @type {?} */ data = this._data;\n            var /** @type {?} */ dataWords = data.words;\n            var /** @type {?} */ nBitsTotal = this._nDataBytes * 8;\n            var /** @type {?} */ nBitsLeft = data.sigBytes * 8;\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            var /** @type {?} */ nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n            var /** @type {?} */ nBitsTotalL = nBitsTotal;\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00));\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00));\n            data.sigBytes = (dataWords.length + 1) * 4;\n            // Hash final blocks\n            this._process();\n            // Shortcuts\n            var /** @type {?} */ hash = this._hash;\n            var /** @type {?} */ H = hash.words;\n            // Swap endian\n            for (var /** @type {?} */ i = 0; i < 4; i++) {\n                // Shortcut\n                var /** @type {?} */ H_i = H[i];\n                H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |\n                    (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n            }\n            // Return final computed hash\n            return hash;\n        };\n        return MD5;\n    }(Hasher));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var EvpKDF = /** @class */ (function () {\n        /**\n         * Initializes a newly created key derivation function.\n         *\n         * @param cfg (Optional) The configuration options to use for the derivation.\n         *\n         * @example\n         *\n         *     let kdf = EvpKDF.create();\n         *     let kdf = EvpKDF.create({ keySize: 8 });\n         *     let kdf = EvpKDF.create({ keySize: 8, iterations: 1000 });\n         */\n        function EvpKDF(cfg) {\n            this.cfg = Object.assign({\n                keySize: 128 / 32,\n                hasher: MD5,\n                iterations: 1\n            }, cfg);\n        }\n        /**\n         * Derives a key from a password.\n         *\n         * @param password The password.\n         * @param salt A salt.\n         *\n         * @return The derived key.\n         *\n         * @example\n         *\n         *     let key = kdf.compute(password, salt);\n         */\n        /**\n         * Derives a key from a password.\n         *\n         * \\@example\n         *\n         *     let key = kdf.compute(password, salt);\n         * @param {?} password The password.\n         * @param {?} salt A salt.\n         *\n         * @return {?} The derived key.\n         *\n         */\n        EvpKDF.prototype.compute = /**\n         * Derives a key from a password.\n         *\n         * \\@example\n         *\n         *     let key = kdf.compute(password, salt);\n         * @param {?} password The password.\n         * @param {?} salt A salt.\n         *\n         * @return {?} The derived key.\n         *\n         */\n        function (password, salt) {\n            // Init hasher\n            var /** @type {?} */ hasher = new (/** @type {?} */ (this.cfg.hasher))();\n            // Initial values\n            var /** @type {?} */ derivedKey = new WordArray();\n            // Generate key\n            var /** @type {?} */ block;\n            while (derivedKey.words.length < this.cfg.keySize) {\n                if (block) {\n                    hasher.update(block);\n                }\n                block = hasher.update(password).finalize(salt);\n                hasher.reset();\n                // Iterations\n                for (var /** @type {?} */ i = 1; i < this.cfg.iterations; i++) {\n                    block = hasher.finalize(block);\n                    hasher.reset();\n                }\n                derivedKey.concat(block);\n            }\n            derivedKey.sigBytes = this.cfg.keySize * 4;\n            return derivedKey;\n        };\n        return EvpKDF;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var OpenSSLKdf = /** @class */ (function () {\n        function OpenSSLKdf() {\n        }\n        /**\n         * Derives a key and IV from a password.\n         *\n         * \\@example\n         *\n         *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32);\n         *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n         * @param {?} password The password to derive from.\n         * @param {?} keySize The size in words of the key to generate.\n         * @param {?} ivSize The size in words of the IV to generate.\n         * @param {?=} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n         *\n         * @return {?} A cipher params object with the key, IV, and salt.\n         *\n         */\n        OpenSSLKdf.execute = /**\n         * Derives a key and IV from a password.\n         *\n         * \\@example\n         *\n         *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32);\n         *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n         * @param {?} password The password to derive from.\n         * @param {?} keySize The size in words of the key to generate.\n         * @param {?} ivSize The size in words of the IV to generate.\n         * @param {?=} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n         *\n         * @return {?} A cipher params object with the key, IV, and salt.\n         *\n         */\n        function (password, keySize, ivSize, salt) {\n            // Generate random salt\n            if (!salt) {\n                salt = WordArray.random(64 / 8);\n            }\n            // Derive key and IV\n            var /** @type {?} */ key = (new EvpKDF({ keySize: keySize + ivSize })).compute(password, salt);\n            // Separate key and IV\n            var /** @type {?} */ iv = new WordArray(key.words.slice(keySize), ivSize * 4);\n            key.sigBytes = keySize * 4;\n            // Return params\n            return new CipherParams({ key: key, iv: iv, salt: salt });\n        };\n        return OpenSSLKdf;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var PasswordBasedCipher = /** @class */ (function () {\n        function PasswordBasedCipher() {\n        }\n        /**\n         * Encrypts a message using a password.\n         *\n         * \\@example\n         *\n         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password');\n         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password', { format: OpenSSL });\n         * @param {?} cipher The cipher algorithm to use.\n         * @param {?} message The message to encrypt.\n         * @param {?} password The password.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} A cipher params object.\n         *\n         */\n        PasswordBasedCipher.encrypt = /**\n         * Encrypts a message using a password.\n         *\n         * \\@example\n         *\n         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password');\n         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password', { format: OpenSSL });\n         * @param {?} cipher The cipher algorithm to use.\n         * @param {?} message The message to encrypt.\n         * @param {?} password The password.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} A cipher params object.\n         *\n         */\n        function (cipher, message, password, cfg) {\n            // Apply config defaults\n            var /** @type {?} */ config = Object.assign({}, this.cfg, cfg);\n            // Check if we have a kdf\n            if (config.kdf === undefined) {\n                throw new Error('missing kdf in config');\n            }\n            // Derive key and other params\n            var /** @type {?} */ derivedParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize);\n            // Check if we have an IV\n            if (derivedParams.iv !== undefined) {\n                // Add IV to config\n                config.iv = derivedParams.iv;\n            }\n            // Encrypt\n            var /** @type {?} */ ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, config);\n            // Mix in derived params\n            return ciphertext.extend(derivedParams);\n        };\n        /**\n         * Decrypts serialized ciphertext using a password.\n         *\n         * \\@example\n         *\n         *     var plaintext = PasswordBasedCipher.decrypt(AES, formattedCiphertext, 'password', { format: OpenSSL });\n         *     var plaintext = PasswordBasedCipher.decrypt(AES, ciphertextParams, 'password', { format: OpenSSL });\n         * @param {?} cipher The cipher algorithm to use.\n         * @param {?} ciphertext The ciphertext to decrypt.\n         * @param {?} password The password.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} The plaintext.\n         *\n         */\n        PasswordBasedCipher.decrypt = /**\n         * Decrypts serialized ciphertext using a password.\n         *\n         * \\@example\n         *\n         *     var plaintext = PasswordBasedCipher.decrypt(AES, formattedCiphertext, 'password', { format: OpenSSL });\n         *     var plaintext = PasswordBasedCipher.decrypt(AES, ciphertextParams, 'password', { format: OpenSSL });\n         * @param {?} cipher The cipher algorithm to use.\n         * @param {?} ciphertext The ciphertext to decrypt.\n         * @param {?} password The password.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} The plaintext.\n         *\n         */\n        function (cipher, ciphertext, password, cfg) {\n            // Apply config defaults\n            var /** @type {?} */ config = Object.assign({}, this.cfg, cfg);\n            // Check if we have a kdf\n            if (config.format === undefined) {\n                throw new Error('missing format in config');\n            }\n            // Convert string to CipherParams\n            ciphertext = this._parse(ciphertext, config.format);\n            // Check if we have a kdf\n            if (config.kdf === undefined) {\n                throw new Error('the key derivation function must be set');\n            }\n            // Derive key and other params\n            var /** @type {?} */ derivedParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n            // Check if we have an IV\n            if (derivedParams.iv !== undefined) {\n                // Add IV to config\n                config.iv = derivedParams.iv;\n            }\n            // Decrypt\n            var /** @type {?} */ plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, config);\n            return plaintext;\n        };\n        /**\n         * Converts serialized ciphertext to CipherParams,\n         * else assumed CipherParams already and returns ciphertext unchanged.\n         *\n         * \\@example\n         *\n         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n         * @param {?} ciphertext The ciphertext.\n         * @param {?} format The formatting strategy to use to parse serialized ciphertext.\n         *\n         * @return {?} The unserialized ciphertext.\n         *\n         */\n        PasswordBasedCipher._parse = /**\n         * Converts serialized ciphertext to CipherParams,\n         * else assumed CipherParams already and returns ciphertext unchanged.\n         *\n         * \\@example\n         *\n         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n         * @param {?} ciphertext The ciphertext.\n         * @param {?} format The formatting strategy to use to parse serialized ciphertext.\n         *\n         * @return {?} The unserialized ciphertext.\n         *\n         */\n        function (ciphertext, format) {\n            if (typeof ciphertext === 'string') {\n                return format.parse(ciphertext);\n            }\n            else {\n                return ciphertext;\n            }\n        };\n        PasswordBasedCipher.cfg = {\n            blockSize: 4,\n            iv: new WordArray([]),\n            format: OpenSSL,\n            kdf: OpenSSLKdf\n        };\n        return PasswordBasedCipher;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * @abstract\n     */\n    var Cipher = /** @class */ (function (_super) {\n        __extends(Cipher, _super);\n        function Cipher(xformMode, key, cfg) {\n            var _this = \n            // Apply config defaults\n            _super.call(this, Object.assign({\n                blockSize: 1\n            }, cfg)) || this;\n            // Store transform mode and key\n            // Store transform mode and key\n            _this._xformMode = xformMode;\n            _this._key = key;\n            // Set initial values\n            // Set initial values\n            _this.reset();\n            return _this;\n        }\n        /**\n         * Creates this cipher in encryption mode.\n         *\n         * \\@example\n         *\n         *     let cipher = AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n         * @param {?} key The key.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} A cipher instance.\n         *\n         */\n        Cipher.createEncryptor = /**\n         * Creates this cipher in encryption mode.\n         *\n         * \\@example\n         *\n         *     let cipher = AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n         * @param {?} key The key.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} A cipher instance.\n         *\n         */\n        function (key, cfg) {\n            // workaround for typescript not being able to create a abstract creator function directly\n            var /** @type {?} */ thisClass = this;\n            return new thisClass(this._ENC_XFORM_MODE, key, cfg);\n        };\n        /**\n         * Creates this cipher in decryption mode.\n         *\n         * \\@example\n         *\n         *     let cipher = AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n         * @param {?} key The key.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} A cipher instance.\n         *\n         */\n        Cipher.createDecryptor = /**\n         * Creates this cipher in decryption mode.\n         *\n         * \\@example\n         *\n         *     let cipher = AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n         * @param {?} key The key.\n         * @param {?=} cfg (Optional) The configuration options to use for this operation.\n         *\n         * @return {?} A cipher instance.\n         *\n         */\n        function (key, cfg) {\n            // workaround for typescript not being able to create a abstract creator function directly\n            var /** @type {?} */ thisClass = this;\n            return new thisClass(this._DEC_XFORM_MODE, key, cfg);\n        };\n        /**\n         * Creates shortcut functions to a cipher's object interface.\n         *\n         * \\@example\n         *\n         *     let AES = Cipher._createHelper(AESAlgorithm);\n         * @param {?} cipher The cipher to create a helper for.\n         *\n         * @return {?} An object with encrypt and decrypt shortcut functions.\n         *\n         */\n        Cipher._createHelper = /**\n         * Creates shortcut functions to a cipher's object interface.\n         *\n         * \\@example\n         *\n         *     let AES = Cipher._createHelper(AESAlgorithm);\n         * @param {?} cipher The cipher to create a helper for.\n         *\n         * @return {?} An object with encrypt and decrypt shortcut functions.\n         *\n         */\n        function (cipher) {\n            /**\n             * @param {?} message\n             * @param {?} key\n             * @param {?=} cfg\n             * @return {?}\n             */\n            function encrypt(message, key, cfg) {\n                if (typeof key === 'string') {\n                    return PasswordBasedCipher.encrypt(cipher, message, key, cfg);\n                }\n                else {\n                    return SerializableCipher.encrypt(cipher, message, key, cfg);\n                }\n            }\n            /**\n             * @param {?} ciphertext\n             * @param {?} key\n             * @param {?=} cfg\n             * @return {?}\n             */\n            function decrypt(ciphertext, key, cfg) {\n                if (typeof key === 'string') {\n                    return PasswordBasedCipher.decrypt(cipher, ciphertext, key, cfg);\n                }\n                else {\n                    return SerializableCipher.decrypt(cipher, ciphertext, key, cfg);\n                }\n            }\n            return {\n                encrypt: encrypt,\n                decrypt: decrypt\n            };\n        };\n        /**\n         * Adds data to be encrypted or decrypted.\n         *\n         * \\@example\n         *\n         *     let encrypted = cipher.process('data');\n         *     let encrypted = cipher.process(wordArray);\n         * @param {?} dataUpdate The data to encrypt or decrypt.\n         *\n         * @return {?} The data after processing.\n         *\n         */\n        Cipher.prototype.process = /**\n         * Adds data to be encrypted or decrypted.\n         *\n         * \\@example\n         *\n         *     let encrypted = cipher.process('data');\n         *     let encrypted = cipher.process(wordArray);\n         * @param {?} dataUpdate The data to encrypt or decrypt.\n         *\n         * @return {?} The data after processing.\n         *\n         */\n        function (dataUpdate) {\n            // Append\n            this._append(dataUpdate);\n            // Process available blocks\n            return this._process();\n        };\n        /**\n         * Finalizes the encryption or decryption process.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * \\@example\n         *\n         *     var encrypted = cipher.finalize();\n         *     var encrypted = cipher.finalize('data');\n         *     var encrypted = cipher.finalize(wordArray);\n         * @param {?=} dataUpdate The final data to encrypt or decrypt.\n         *\n         * @return {?} The data after final processing.\n         *\n         */\n        Cipher.prototype.finalize = /**\n         * Finalizes the encryption or decryption process.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * \\@example\n         *\n         *     var encrypted = cipher.finalize();\n         *     var encrypted = cipher.finalize('data');\n         *     var encrypted = cipher.finalize(wordArray);\n         * @param {?=} dataUpdate The final data to encrypt or decrypt.\n         *\n         * @return {?} The data after final processing.\n         *\n         */\n        function (dataUpdate) {\n            // Final data update\n            if (dataUpdate) {\n                this._append(dataUpdate);\n            }\n            // Perform concrete-cipher logic\n            var /** @type {?} */ finalProcessedData = this._doFinalize();\n            return finalProcessedData;\n        };\n        /**\n         * A constant representing encryption mode.\n         */\n        Cipher._ENC_XFORM_MODE = 1;\n        /**\n         * A constant representing decryption mode.\n         */\n        Cipher._DEC_XFORM_MODE = 2;\n        /**\n         * This cipher's key size. Default: 4 (128 bits / 32 Bits)\n         */\n        Cipher.keySize = 4;\n        /**\n         * This cipher's IV size. Default: 4 (128 bits / 32 Bits)\n         */\n        Cipher.ivSize = 4;\n        return Cipher;\n    }(BufferedBlockAlgorithm));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * @abstract\n     */\n    var /**\n     * @abstract\n     */\n    BlockCipherModeAlgorithm = /** @class */ (function () {\n        function BlockCipherModeAlgorithm(cipher, iv) {\n            this.init(cipher, iv);\n        }\n        /**\n         * Initializes a newly created mode.\n         *\n         * \\@example\n         *\n         *     var mode = CBC.Encryptor.create(cipher, iv.words);\n         * @param {?} cipher A block cipher instance.\n         * @param {?=} iv The IV words.\n         *\n         * @return {?}\n         */\n        BlockCipherModeAlgorithm.prototype.init = /**\n         * Initializes a newly created mode.\n         *\n         * \\@example\n         *\n         *     var mode = CBC.Encryptor.create(cipher, iv.words);\n         * @param {?} cipher A block cipher instance.\n         * @param {?=} iv The IV words.\n         *\n         * @return {?}\n         */\n        function (cipher, iv) {\n            this._cipher = cipher;\n            this._iv = iv;\n        };\n        return BlockCipherModeAlgorithm;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * @abstract\n     */\n    var BlockCipherMode = /** @class */ (function () {\n        function BlockCipherMode() {\n        }\n        /**\n         * Creates this mode for encryption.\n         *\n         * \\@example\n         *\n         *     var mode = CBC.createEncryptor(cipher, iv.words);\n         * @param {?} cipher A block cipher instance.\n         * @param {?} iv The IV words.\n         *\n         * @return {?}\n         */\n        BlockCipherMode.createEncryptor = /**\n         * Creates this mode for encryption.\n         *\n         * \\@example\n         *\n         *     var mode = CBC.createEncryptor(cipher, iv.words);\n         * @param {?} cipher A block cipher instance.\n         * @param {?} iv The IV words.\n         *\n         * @return {?}\n         */\n        function (cipher, iv) {\n            // workaround for typescript not being able to create a abstract creator function directly\n            var /** @type {?} */ encryptorClass = this.Encryptor;\n            return new encryptorClass(cipher, iv);\n        };\n        /**\n         * Creates this mode for decryption.\n         *\n         * \\@example\n         *\n         *     var mode = CBC.createDecryptor(cipher, iv.words);\n         * @param {?} cipher A block cipher instance.\n         * @param {?} iv The IV words.\n         *\n         * @return {?}\n         */\n        BlockCipherMode.createDecryptor = /**\n         * Creates this mode for decryption.\n         *\n         * \\@example\n         *\n         *     var mode = CBC.createDecryptor(cipher, iv.words);\n         * @param {?} cipher A block cipher instance.\n         * @param {?} iv The IV words.\n         *\n         * @return {?}\n         */\n        function (cipher, iv) {\n            // workaround for typescript not being able to create a abstract creator function directly\n            var /** @type {?} */ decryptorClass = this.Decryptor;\n            return new decryptorClass(cipher, iv);\n        };\n        BlockCipherMode.Encryptor = BlockCipherModeAlgorithm;\n        BlockCipherMode.Decryptor = BlockCipherModeAlgorithm;\n        return BlockCipherMode;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var CBCEncryptor = /** @class */ (function (_super) {\n        __extends(CBCEncryptor, _super);\n        function CBCEncryptor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * Processes the data block at offset.\n         *\n         * \\@example\n         *\n         *     mode.processBlock(data.words, offset);\n         * @param {?} words The data words to operate on.\n         * @param {?} offset The offset where the block starts.\n         *\n         * @return {?}\n         */\n        CBCEncryptor.prototype.processBlock = /**\n         * Processes the data block at offset.\n         *\n         * \\@example\n         *\n         *     mode.processBlock(data.words, offset);\n         * @param {?} words The data words to operate on.\n         * @param {?} offset The offset where the block starts.\n         *\n         * @return {?}\n         */\n        function (words, offset) {\n            // Check if we have a blockSize\n            if (this._cipher.cfg.blockSize === undefined) {\n                throw new Error('missing blockSize in cipher config');\n            }\n            // XOR and encrypt\n            this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n            this._cipher.encryptBlock(words, offset);\n            // Remember this block to use with next block\n            this._prevBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n        };\n        /**\n         * @param {?} words\n         * @param {?} offset\n         * @param {?} blockSize\n         * @return {?}\n         */\n        CBCEncryptor.prototype.xorBlock = /**\n         * @param {?} words\n         * @param {?} offset\n         * @param {?} blockSize\n         * @return {?}\n         */\n        function (words, offset, blockSize) {\n            // Choose mixing block\n            var /** @type {?} */ block;\n            if (this._iv) {\n                block = this._iv;\n                // Remove IV for subsequent blocks\n                this._iv = undefined;\n            }\n            else {\n                block = this._prevBlock;\n            }\n            // block should never be undefined but we want to make typescript happy\n            if (block !== undefined) {\n                // XOR blocks\n                for (var /** @type {?} */ i = 0; i < blockSize; i++) {\n                    words[offset + i] ^= block[i];\n                }\n            }\n        };\n        return CBCEncryptor;\n    }(BlockCipherModeAlgorithm));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var CBCDecryptor = /** @class */ (function (_super) {\n        __extends(CBCDecryptor, _super);\n        function CBCDecryptor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * Processes the data block at offset.\n         *\n         * \\@example\n         *\n         *     mode.processBlock(data.words, offset);\n         * @param {?} words The data words to operate on.\n         * @param {?} offset The offset where the block starts.\n         *\n         * @return {?}\n         */\n        CBCDecryptor.prototype.processBlock = /**\n         * Processes the data block at offset.\n         *\n         * \\@example\n         *\n         *     mode.processBlock(data.words, offset);\n         * @param {?} words The data words to operate on.\n         * @param {?} offset The offset where the block starts.\n         *\n         * @return {?}\n         */\n        function (words, offset) {\n            // Check if we have a blockSize\n            if (this._cipher.cfg.blockSize === undefined) {\n                throw new Error('missing blockSize in cipher config');\n            }\n            // Remember this block to use with next block\n            var /** @type {?} */ thisBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n            // Decrypt and XOR\n            this._cipher.decryptBlock(words, offset);\n            this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n            // This block becomes the previous block\n            this._prevBlock = thisBlock;\n        };\n        /**\n         * @param {?} words\n         * @param {?} offset\n         * @param {?} blockSize\n         * @return {?}\n         */\n        CBCDecryptor.prototype.xorBlock = /**\n         * @param {?} words\n         * @param {?} offset\n         * @param {?} blockSize\n         * @return {?}\n         */\n        function (words, offset, blockSize) {\n            // Choose mixing block\n            var /** @type {?} */ block;\n            if (this._iv) {\n                block = this._iv;\n                // Remove IV for subsequent blocks\n                this._iv = undefined;\n            }\n            else {\n                block = this._prevBlock;\n            }\n            // block should never be undefined but we want to make typescript happy\n            if (block !== undefined) {\n                // XOR blocks\n                for (var /** @type {?} */ i = 0; i < blockSize; i++) {\n                    words[offset + i] ^= block[i];\n                }\n            }\n        };\n        return CBCDecryptor;\n    }(BlockCipherModeAlgorithm));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * Cipher Block Chaining mode.\n     * @abstract\n     */\n    var CBC = /** @class */ (function (_super) {\n        __extends(CBC, _super);\n        function CBC() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        CBC.Encryptor = CBCEncryptor;\n        CBC.Decryptor = CBCDecryptor;\n        return CBC;\n    }(BlockCipherMode));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var PKCS7 = /** @class */ (function () {\n        function PKCS7() {\n        }\n        /**\n         * Pads data using the algorithm defined in PKCS #5/7.\n         *\n         * \\@example\n         *\n         *     PKCS7.pad(wordArray, 4);\n         * @param {?} data The data to pad.\n         * @param {?} blockSize The multiple that the data should be padded to.\n         *\n         * @return {?}\n         */\n        PKCS7.pad = /**\n         * Pads data using the algorithm defined in PKCS #5/7.\n         *\n         * \\@example\n         *\n         *     PKCS7.pad(wordArray, 4);\n         * @param {?} data The data to pad.\n         * @param {?} blockSize The multiple that the data should be padded to.\n         *\n         * @return {?}\n         */\n        function (data, blockSize) {\n            // Shortcut\n            var /** @type {?} */ blockSizeBytes = blockSize * 4;\n            // Count padding bytes\n            var /** @type {?} */ nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n            // Create padding word\n            var /** @type {?} */ paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n            // Create padding\n            var /** @type {?} */ paddingWords = [];\n            for (var /** @type {?} */ i = 0; i < nPaddingBytes; i += 4) {\n                paddingWords.push(paddingWord);\n            }\n            var /** @type {?} */ padding = new WordArray(paddingWords, nPaddingBytes);\n            // Add padding\n            data.concat(padding);\n        };\n        /**\n         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n         *\n         * \\@example\n         *\n         *     PKCS7.unpad(wordArray);\n         * @param {?} data The data to unpad.\n         *\n         * @return {?}\n         */\n        PKCS7.unpad = /**\n         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n         *\n         * \\@example\n         *\n         *     PKCS7.unpad(wordArray);\n         * @param {?} data The data to unpad.\n         *\n         * @return {?}\n         */\n        function (data) {\n            // Get number of padding bytes from last byte\n            var /** @type {?} */ nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n            // Remove padding\n            data.sigBytes -= nPaddingBytes;\n        };\n        return PKCS7;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * @abstract\n     */\n    var   /**\n     * @abstract\n     */\n    BlockCipher = /** @class */ (function (_super) {\n        __extends(BlockCipher, _super);\n        function BlockCipher(xformMode, key, cfg) {\n            return _super.call(this, xformMode, key, Object.assign({\n                // default: 128 / 32\n                blockSize: 4,\n                mode: CBC,\n                padding: PKCS7\n            }, cfg)) || this;\n        }\n        /**\n         * @return {?}\n         */\n        BlockCipher.prototype.reset = /**\n         * @return {?}\n         */\n        function () {\n            // Reset cipher\n            _super.prototype.reset.call(this);\n            // Check if we have a blockSize\n            if (this.cfg.mode === undefined) {\n                throw new Error('missing mode in config');\n            }\n            // Reset block mode\n            var /** @type {?} */ modeCreator;\n            if (this._xformMode === (/** @type {?} */ (this.constructor))._ENC_XFORM_MODE) {\n                modeCreator = this.cfg.mode.createEncryptor;\n            }\n            else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n                modeCreator = this.cfg.mode.createDecryptor;\n                // Keep at least one block in the buffer for unpadding\n                this._minBufferSize = 1;\n            }\n            if (this._mode && this._mode.__creator === modeCreator) {\n                this._mode.init(this, this.cfg.iv && this.cfg.iv.words);\n            }\n            else {\n                this._mode = modeCreator.call(this.cfg.mode, this, this.cfg.iv && this.cfg.iv.words);\n                this._mode.__creator = modeCreator;\n            }\n        };\n        /**\n         * @param {?} words\n         * @param {?} offset\n         * @return {?}\n         */\n        BlockCipher.prototype._doProcessBlock = /**\n         * @param {?} words\n         * @param {?} offset\n         * @return {?}\n         */\n        function (words, offset) {\n            this._mode.processBlock(words, offset);\n        };\n        /**\n         * @return {?}\n         */\n        BlockCipher.prototype._doFinalize = /**\n         * @return {?}\n         */\n        function () {\n            // Check if we have a padding strategy\n            if (this.cfg.padding === undefined) {\n                throw new Error('missing padding in config');\n            }\n            // Finalize\n            var /** @type {?} */ finalProcessedBlocks;\n            if (this._xformMode === (/** @type {?} */ (this.constructor))._ENC_XFORM_MODE) {\n                // Check if we have a blockSize\n                if (this.cfg.blockSize === undefined) {\n                    throw new Error('missing blockSize in config');\n                }\n                // Pad data\n                this.cfg.padding.pad(this._data, this.cfg.blockSize);\n                // Process final blocks\n                finalProcessedBlocks = this._process(!!'flush');\n            }\n            else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n                // Process final blocks\n                finalProcessedBlocks = this._process(!!'flush');\n                // Unpad data\n                this.cfg.padding.unpad(finalProcessedBlocks);\n            }\n            return finalProcessedBlocks;\n        };\n        return BlockCipher;\n    }(Cipher));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    // Define lookup tables\n    var /** @type {?} */ SBOX = [];\n    var /** @type {?} */ INV_SBOX = [];\n    var /** @type {?} */ SUB_MIX_0 = [];\n    var /** @type {?} */ SUB_MIX_1 = [];\n    var /** @type {?} */ SUB_MIX_2 = [];\n    var /** @type {?} */ SUB_MIX_3 = [];\n    var /** @type {?} */ INV_SUB_MIX_0 = [];\n    var /** @type {?} */ INV_SUB_MIX_1 = [];\n    var /** @type {?} */ INV_SUB_MIX_2 = [];\n    var /** @type {?} */ INV_SUB_MIX_3 = [];\n    // Compute lookup tables\n    (function () {\n        // Compute double table\n        var /** @type {?} */ d = [];\n        for (var /** @type {?} */ i = 0; i < 256; i++) {\n            if (i < 128) {\n                d[i] = i << 1;\n            }\n            else {\n                d[i] = (i << 1) ^ 0x11b;\n            }\n        }\n        // Walk GF(2^8)\n        var /** @type {?} */ x = 0;\n        var /** @type {?} */ xi = 0;\n        for (var /** @type {?} */ i = 0; i < 256; i++) {\n            // Compute sbox\n            var /** @type {?} */ sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n            SBOX[x] = sx;\n            INV_SBOX[sx] = x;\n            // Compute multiplication\n            var /** @type {?} */ x2 = d[x];\n            var /** @type {?} */ x4 = d[x2];\n            var /** @type {?} */ x8 = d[x4];\n            // Compute sub bytes, mix columns tables\n            var /** @type {?} */ t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n            SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n            SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n            SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n            SUB_MIX_3[x] = t;\n            // Compute inv sub bytes, inv mix columns tables\n            t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n            INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n            INV_SUB_MIX_3[sx] = t;\n            // Compute next counter\n            if (!x) {\n                x = xi = 1;\n            }\n            else {\n                x = x2 ^ d[d[d[x8 ^ x2]]];\n                xi ^= d[d[xi]];\n            }\n        }\n    }());\n    // Precomputed Rcon lookup\n    var /** @type {?} */ RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    var AES = /** @class */ (function (_super) {\n        __extends(AES, _super);\n        function AES(xformMode, key, cfg) {\n            return _super.call(this, xformMode, key, cfg) || this;\n        }\n        /**\n         * @return {?}\n         */\n        AES.prototype.reset = /**\n         * @return {?}\n         */\n        function () {\n            // reset core values\n            _super.prototype.reset.call(this);\n            // Skip reset of nRounds has been set before and key did not change\n            if (this._nRounds && this._keyPriorReset === this._key) {\n                return;\n            }\n            // Shortcuts\n            var /** @type {?} */ key = this._keyPriorReset = this._key;\n            var /** @type {?} */ keyWords = key.words;\n            var /** @type {?} */ keySize = key.sigBytes / 4;\n            // Compute number of rounds\n            var /** @type {?} */ nRounds = this._nRounds = keySize + 6;\n            // Compute number of key schedule rows\n            var /** @type {?} */ ksRows = (nRounds + 1) * 4;\n            // Compute key schedule\n            var /** @type {?} */ keySchedule = this._keySchedule = [];\n            for (var /** @type {?} */ ksRow = 0; ksRow < ksRows; ksRow++) {\n                if (ksRow < keySize) {\n                    keySchedule[ksRow] = keyWords[ksRow];\n                }\n                else {\n                    var /** @type {?} */ t = keySchedule[ksRow - 1];\n                    if (!(ksRow % keySize)) {\n                        // Rot word\n                        t = (t << 8) | (t >>> 24);\n                        // Sub word\n                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n                        // Mix Rcon\n                        t ^= RCON[(ksRow / keySize) | 0] << 24;\n                    }\n                    else if (keySize > 6 && ksRow % keySize === 4) {\n                        // Sub word\n                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n                    }\n                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n                }\n            }\n            // Compute inv key schedule\n            var /** @type {?} */ invKeySchedule = this._invKeySchedule = [];\n            for (var /** @type {?} */ invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n                var /** @type {?} */ ksRow = ksRows - invKsRow;\n                var /** @type {?} */ t = void 0;\n                if (invKsRow % 4) {\n                    t = keySchedule[ksRow];\n                }\n                else {\n                    t = keySchedule[ksRow - 4];\n                }\n                if (invKsRow < 4 || ksRow <= 4) {\n                    invKeySchedule[invKsRow] = t;\n                }\n                else {\n                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n                        INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n                }\n            }\n        };\n        /**\n         * @param {?} M\n         * @param {?} offset\n         * @return {?}\n         */\n        AES.prototype.encryptBlock = /**\n         * @param {?} M\n         * @param {?} offset\n         * @return {?}\n         */\n        function (M, offset) {\n            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n        };\n        /**\n         * @param {?} M\n         * @param {?} offset\n         * @return {?}\n         */\n        AES.prototype.decryptBlock = /**\n         * @param {?} M\n         * @param {?} offset\n         * @return {?}\n         */\n        function (M, offset) {\n            // Swap 2nd and 4th rows\n            var /** @type {?} */ t = M[offset + 1];\n            M[offset + 1] = M[offset + 3];\n            M[offset + 3] = t;\n            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n            // Inv swap 2nd and 4th rows\n            t = M[offset + 1];\n            M[offset + 1] = M[offset + 3];\n            M[offset + 3] = t;\n        };\n        /**\n         * @param {?} M\n         * @param {?} offset\n         * @param {?} keySchedule\n         * @param {?} sub_mix_0\n         * @param {?} sub_mix_1\n         * @param {?} sub_mix_2\n         * @param {?} sub_mix_3\n         * @param {?} sbox\n         * @return {?}\n         */\n        AES.prototype._doCryptBlock = /**\n         * @param {?} M\n         * @param {?} offset\n         * @param {?} keySchedule\n         * @param {?} sub_mix_0\n         * @param {?} sub_mix_1\n         * @param {?} sub_mix_2\n         * @param {?} sub_mix_3\n         * @param {?} sbox\n         * @return {?}\n         */\n        function (M, offset, keySchedule, sub_mix_0, sub_mix_1, sub_mix_2, sub_mix_3, sbox) {\n            // Get input, add round key\n            var /** @type {?} */ s0 = M[offset] ^ keySchedule[0];\n            var /** @type {?} */ s1 = M[offset + 1] ^ keySchedule[1];\n            var /** @type {?} */ s2 = M[offset + 2] ^ keySchedule[2];\n            var /** @type {?} */ s3 = M[offset + 3] ^ keySchedule[3];\n            // Key schedule row counter\n            var /** @type {?} */ ksRow = 4;\n            // Rounds\n            for (var /** @type {?} */ round = 1; round < this._nRounds; round++) {\n                // Shift rows, sub bytes, mix columns, add round key\n                var /** @type {?} */ t0 = sub_mix_0[s0 >>> 24] ^ sub_mix_1[(s1 >>> 16) & 0xff] ^ sub_mix_2[(s2 >>> 8) & 0xff] ^ sub_mix_3[s3 & 0xff] ^\n                    keySchedule[ksRow++];\n                var /** @type {?} */ t1 = sub_mix_0[s1 >>> 24] ^ sub_mix_1[(s2 >>> 16) & 0xff] ^ sub_mix_2[(s3 >>> 8) & 0xff] ^ sub_mix_3[s0 & 0xff] ^\n                    keySchedule[ksRow++];\n                var /** @type {?} */ t2 = sub_mix_0[s2 >>> 24] ^ sub_mix_1[(s3 >>> 16) & 0xff] ^ sub_mix_2[(s0 >>> 8) & 0xff] ^ sub_mix_3[s1 & 0xff] ^\n                    keySchedule[ksRow++];\n                var /** @type {?} */ t3 = sub_mix_0[s3 >>> 24] ^ sub_mix_1[(s0 >>> 16) & 0xff] ^ sub_mix_2[(s1 >>> 8) & 0xff] ^ sub_mix_3[s2 & 0xff] ^\n                    keySchedule[ksRow++];\n                // Update state\n                s0 = t0;\n                s1 = t1;\n                s2 = t2;\n                s3 = t3;\n            }\n            // Shift rows, sub bytes, add round key\n            var /** @type {?} */ t0g = ((sbox[s0 >>> 24] << 24) | (sbox[(s1 >>> 16) & 0xff] << 16) | (sbox[(s2 >>> 8) & 0xff] << 8) | sbox[s3 & 0xff]) ^\n                keySchedule[ksRow++];\n            var /** @type {?} */ t1g = ((sbox[s1 >>> 24] << 24) | (sbox[(s2 >>> 16) & 0xff] << 16) | (sbox[(s3 >>> 8) & 0xff] << 8) | sbox[s0 & 0xff]) ^\n                keySchedule[ksRow++];\n            var /** @type {?} */ t2g = ((sbox[s2 >>> 24] << 24) | (sbox[(s3 >>> 16) & 0xff] << 16) | (sbox[(s0 >>> 8) & 0xff] << 8) | sbox[s1 & 0xff]) ^\n                keySchedule[ksRow++];\n            var /** @type {?} */ t3g = ((sbox[s3 >>> 24] << 24) | (sbox[(s0 >>> 16) & 0xff] << 16) | (sbox[(s1 >>> 8) & 0xff] << 8) | sbox[s2 & 0xff]) ^\n                keySchedule[ksRow++];\n            // Set output\n            M[offset] = t0g;\n            M[offset + 1] = t1g;\n            M[offset + 2] = t2g;\n            M[offset + 3] = t3g;\n        };\n        AES.keySize = 8;\n        return AES;\n    }(BlockCipher));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    // Initialization and round constants tables\n    var /** @type {?} */ H = [];\n    var /** @type {?} */ K = [];\n    // Reusable object\n    var /** @type {?} */ W = [];\n    var SHA256 = /** @class */ (function (_super) {\n        __extends(SHA256, _super);\n        function SHA256() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * @return {?}\n         */\n        SHA256.prototype.reset = /**\n         * @return {?}\n         */\n        function () {\n            // reset core values\n            _super.prototype.reset.call(this);\n            this._hash = new WordArray(H.slice(0));\n        };\n        /**\n         * @param {?} M\n         * @param {?} offset\n         * @return {?}\n         */\n        SHA256.prototype._doProcessBlock = /**\n         * @param {?} M\n         * @param {?} offset\n         * @return {?}\n         */\n        function (M, offset) {\n            // Shortcut\n            var /** @type {?} */ Hl = this._hash.words;\n            // Working variables\n            var /** @type {?} */ a = Hl[0];\n            var /** @type {?} */ b = Hl[1];\n            var /** @type {?} */ c = Hl[2];\n            var /** @type {?} */ d = Hl[3];\n            var /** @type {?} */ e = Hl[4];\n            var /** @type {?} */ f = Hl[5];\n            var /** @type {?} */ g = Hl[6];\n            var /** @type {?} */ h = Hl[7];\n            // Computation\n            for (var /** @type {?} */ i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                }\n                else {\n                    var /** @type {?} */ gamma0x = W[i - 15];\n                    var /** @type {?} */ gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^\n                        ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                        (gamma0x >>> 3);\n                    var /** @type {?} */ gamma1x = W[i - 2];\n                    var /** @type {?} */ gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                        ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                        (gamma1x >>> 10);\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n                var /** @type {?} */ ch = (e & f) ^ (~e & g);\n                var /** @type {?} */ maj = (a & b) ^ (a & c) ^ (b & c);\n                var /** @type {?} */ sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var /** @type {?} */ sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));\n                var /** @type {?} */ t1 = h + sigma1 + ch + K[i] + W[i];\n                var /** @type {?} */ t2 = sigma0 + maj;\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n            // Intermediate hash value\n            Hl[0] = (Hl[0] + a) | 0;\n            Hl[1] = (Hl[1] + b) | 0;\n            Hl[2] = (Hl[2] + c) | 0;\n            Hl[3] = (Hl[3] + d) | 0;\n            Hl[4] = (Hl[4] + e) | 0;\n            Hl[5] = (Hl[5] + f) | 0;\n            Hl[6] = (Hl[6] + g) | 0;\n            Hl[7] = (Hl[7] + h) | 0;\n        };\n        /**\n         * @return {?}\n         */\n        SHA256.prototype._doFinalize = /**\n         * @return {?}\n         */\n        function () {\n            var /** @type {?} */ nBitsTotal = this._nDataBytes * 8;\n            var /** @type {?} */ nBitsLeft = this._data.sigBytes * 8;\n            // Add padding\n            this._data.words[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            this._data.sigBytes = this._data.words.length * 4;\n            // Hash final blocks\n            this._process();\n            // Return final computed hash\n            return this._hash;\n        };\n        return SHA256;\n    }(Hasher));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NoPadding = /** @class */ (function () {\n        function NoPadding() {\n        }\n        /**\n         * Doesn't pad the data provided.\n         *\n         * \\@example\n         *\n         *     NoPadding.pad(wordArray, 4);\n         * @param {?} data The data to pad.\n         * @param {?} blockSize The multiple that the data should be padded to.\n         *\n         * @return {?}\n         */\n        NoPadding.pad = /**\n         * Doesn't pad the data provided.\n         *\n         * \\@example\n         *\n         *     NoPadding.pad(wordArray, 4);\n         * @param {?} data The data to pad.\n         * @param {?} blockSize The multiple that the data should be padded to.\n         *\n         * @return {?}\n         */\n        function (data, blockSize) {\n        };\n        /**\n         * Doesn't unpad the data provided.\n         *\n         * \\@example\n         *\n         *     NoPadding.unpad(wordArray);\n         * @param {?} data The data to unpad.\n         *\n         * @return {?}\n         */\n        NoPadding.unpad = /**\n         * Doesn't unpad the data provided.\n         *\n         * \\@example\n         *\n         *     NoPadding.unpad(wordArray);\n         * @param {?} data The data to unpad.\n         *\n         * @return {?}\n         */\n        function (data) {\n        };\n        return NoPadding;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var ECBEncryptor = /** @class */ (function (_super) {\n        __extends(ECBEncryptor, _super);\n        function ECBEncryptor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * Processes the data block at offset.\n         *\n         * \\@example\n         *\n         *     mode.processBlock(data.words, offset);\n         * @param {?} words The data words to operate on.\n         * @param {?} offset The offset where the block starts.\n         *\n         * @return {?}\n         */\n        ECBEncryptor.prototype.processBlock = /**\n         * Processes the data block at offset.\n         *\n         * \\@example\n         *\n         *     mode.processBlock(data.words, offset);\n         * @param {?} words The data words to operate on.\n         * @param {?} offset The offset where the block starts.\n         *\n         * @return {?}\n         */\n        function (words, offset) {\n            this._cipher.encryptBlock(words, offset);\n        };\n        return ECBEncryptor;\n    }(BlockCipherModeAlgorithm));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var ECBDecryptor = /** @class */ (function (_super) {\n        __extends(ECBDecryptor, _super);\n        function ECBDecryptor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * Processes the data block at offset.\n         *\n         * \\@example\n         *\n         *     mode.processBlock(data.words, offset);\n         * @param {?} words The data words to operate on.\n         * @param {?} offset The offset where the block starts.\n         *\n         * @return {?}\n         */\n        ECBDecryptor.prototype.processBlock = /**\n         * Processes the data block at offset.\n         *\n         * \\@example\n         *\n         *     mode.processBlock(data.words, offset);\n         * @param {?} words The data words to operate on.\n         * @param {?} offset The offset where the block starts.\n         *\n         * @return {?}\n         */\n        function (words, offset) {\n            this._cipher.decryptBlock(words, offset);\n        };\n        return ECBDecryptor;\n    }(BlockCipherModeAlgorithm));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * Cipher Block Chaining mode.\n     * @abstract\n     */\n    var ECB = /** @class */ (function (_super) {\n        __extends(ECB, _super);\n        function ECB() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ECB.Encryptor = ECBEncryptor;\n        ECB.Decryptor = ECBDecryptor;\n        return ECB;\n    }(BlockCipherMode));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var /** @type {?} */ lib = {\n        BlockCipher: BlockCipher,\n        WordArray: WordArray,\n        CipherParams: CipherParams,\n        Hasher: Hasher,\n        SerializableCipher: SerializableCipher,\n        PasswordBasedCipher: PasswordBasedCipher\n    };\n    var /** @type {?} */ algo = {\n        AES: AES,\n        SHA256: SHA256\n    };\n    var /** @type {?} */ enc = {\n        Utf8: Utf8,\n        Hex: Hex\n    };\n    var /** @type {?} */ pad = {\n        NoPadding: NoPadding,\n        PKCS7: PKCS7\n    };\n    var /** @type {?} */ mode = {\n        CBC: CBC,\n        ECB: ECB\n    };\n    // HELPERS /////////////////////////////////////////////////////////////////////////////////////////\n    var /** @type {?} */ AES$1 = lib.BlockCipher._createHelper(algo.AES);\n    var /** @type {?} */ SHA256$1 = lib.Hasher._createHelper(algo.SHA256);\n\n    exports.lib = lib;\n    exports.algo = algo;\n    exports.enc = enc;\n    exports.pad = pad;\n    exports.mode = mode;\n    exports.AES = AES$1;\n    exports.SHA256 = SHA256$1;\n    exports.ɵl = AES;\n    exports.ɵm = SHA256;\n    exports.ɵp = Hex;\n    exports.ɵo = Latin1;\n    exports.ɵn = Utf8;\n    exports.ɵg = Base;\n    exports.ɵa = BlockCipher;\n    exports.ɵc = BufferedBlockAlgorithm;\n    exports.ɵb = Cipher;\n    exports.ɵf = CipherParams;\n    exports.ɵi = Hasher;\n    exports.ɵk = PasswordBasedCipher;\n    exports.ɵj = SerializableCipher;\n    exports.ɵe = WordArray;\n    exports.ɵt = BlockCipherMode;\n    exports.ɵs = CBC;\n    exports.ɵu = ECB;\n    exports.ɵq = NoPadding;\n    exports.ɵr = PKCS7;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=crypto-ts.umd.js.map\n"]}