"use strict";
exports.id = 917;
exports.ids = [917];
exports.modules = {

/***/ 68214:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatTestError = void 0;
function formatTestError(error) {
    // Possible error cases:
    // - the test found some vulns. `error.message` is a
    // JSON-stringified
    //   test result.
    // - the flow failed, `error` is a real Error object.
    // - the flow failed, `error` is a number or string
    // describing the problem.
    //
    // To standardise this, make sure we use the best _object_ to
    // describe the error.
    let errorResponse;
    if (error instanceof Error) {
        errorResponse = error;
    }
    else if (typeof error !== 'object') {
        errorResponse = new Error(error);
    }
    else {
        try {
            errorResponse = JSON.parse(error.message);
        }
        catch (unused) {
            errorResponse = error;
        }
    }
    return errorResponse;
}
exports.formatTestError = formatTestError;


/***/ }),

/***/ 3937:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.test = void 0;
const assert_iac_options_flag_1 = __webpack_require__(68590);
const measurable_methods_1 = __webpack_require__(78272);
const lib_1 = __webpack_require__(9146);
const get_iac_org_settings_1 = __webpack_require__(1802);
const feature_flags_1 = __webpack_require__(63011);
const config_1 = __webpack_require__(22541);
const camelCase = __webpack_require__(76884);
/**
 * Shim around the new local execution test path and the legacy remote
 * test flow. We also locally deal with the way the legacy test flow exposes
 * the scanned files via the `options.iacDirFiles` object here so that
 * in the new flow we do not mutate the options object.
 */
async function test(pathToScan, options) {
    var _a;
    // Ensure that all flags are correct. We do this to ensure that the
    // caller doesn't accidentally mistype --experimental and send their
    // configuration files to our backend by accident.
    assert_iac_options_flag_1.assertIaCOptionsFlags(process.argv);
    const iacOrgSettings = await get_iac_org_settings_1.getIacOrgSettings(options.org || config_1.default.org);
    const shouldOptOutFromLocalExec = await feature_flags_1.isFeatureFlagSupportedForOrg(camelCase('opt-out-from-local-exec-iac'), iacOrgSettings.meta.org);
    if (shouldOptOutFromLocalExec.ok || options.legacy) {
        // this path allows users to opt-out from the local IaC scan which is GA and continue using the remote-processing legacy flow.
        const results = await lib_1.test(pathToScan, options);
        return {
            failures: (_a = options.iacDirFiles) === null || _a === void 0 ? void 0 : _a.filter((file) => !!file.failureReason),
            results,
        };
    }
    return measurable_methods_1.localTest(pathToScan, options);
}
exports.test = test;


/***/ }),

/***/ 86917:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const Debug = __webpack_require__(15158);
const os_1 = __webpack_require__(12087);
const cloneDeep = __webpack_require__(83465);
const assign = __webpack_require__(31730);
const chalk_1 = __webpack_require__(32589);
const errors_1 = __webpack_require__(55191);
const snyk = __webpack_require__(9146);
const types_1 = __webpack_require__(55246);
const iac_test_result_1 = __webpack_require__(46816);
const formatters_1 = __webpack_require__(81329);
const utils = __webpack_require__(77978);
const iac_output_1 = __webpack_require__(26188);
const ecosystems_1 = __webpack_require__(5168);
const vuln_helpers_1 = __webpack_require__(14784);
const format_test_results_1 = __webpack_require__(59744);
const iac_test_shim_1 = __webpack_require__(3937);
const validate_credentials_1 = __webpack_require__(4593);
const validate_test_options_1 = __webpack_require__(83476);
const set_default_test_options_1 = __webpack_require__(13285);
const process_command_args_1 = __webpack_require__(52369);
const format_test_error_1 = __webpack_require__(68214);
const display_result_1 = __webpack_require__(89667);
const analytics = __webpack_require__(82744);
const protect_update_notification_1 = __webpack_require__(79304);
const spotlight_vuln_notification_1 = __webpack_require__(24083);
const debug = Debug('snyk-test');
const SEPARATOR = '\n-------------------------------------------------------\n';
// TODO: avoid using `as any` whenever it's possible
async function test(...args) {
    const { options: originalOptions, paths } = process_command_args_1.processCommandArgs(...args);
    const options = set_default_test_options_1.setDefaultTestOptions(originalOptions);
    validate_test_options_1.validateTestOptions(options);
    validate_credentials_1.validateCredentials(options);
    const packageJsonPathsWithSnykDepForProtect = protect_update_notification_1.getPackageJsonPathsContainingSnykDependency(options.file, paths);
    analytics.add('upgradable-snyk-protect-paths', packageJsonPathsWithSnykDepForProtect.length);
    // Handles no image arg provided to the container command until
    // a validation interface is implemented in the docker plugin.
    if (options.docker && paths.length === 0) {
        throw new errors_1.MissingArgError();
    }
    const ecosystem = ecosystems_1.getEcosystemForTest(options);
    if (ecosystem) {
        try {
            const commandResult = await ecosystems_1.testEcosystem(ecosystem, paths, options);
            return commandResult;
        }
        catch (error) {
            if (error instanceof Error) {
                throw error;
            }
            else {
                throw new Error(error);
            }
        }
    }
    const resultOptions = [];
    const results = [];
    // Holds an array of scanned file metadata for output.
    let iacScanFailures;
    // Promise waterfall to test all other paths sequentially
    for (const path of paths) {
        // Create a copy of the options so a specific test can
        // modify them i.e. add `options.file` etc. We'll need
        // these options later.
        const testOpts = cloneDeep(options);
        testOpts.path = path;
        testOpts.projectName = testOpts['project-name'];
        let res;
        try {
            if (options.iac) {
                // this path is an experimental feature feature for IaC which does issue scanning locally without sending files to our Backend servers.
                // once ready for GA, it is aimed to deprecate our remote-processing model, so IaC file scanning in the CLI is done locally.
                const { results, failures } = await iac_test_shim_1.test(path, testOpts);
                res = results;
                iacScanFailures = failures;
            }
            else {
                res = await snyk.test(path, testOpts);
            }
        }
        catch (error) {
            // not throwing here but instead returning error response
            // for legacy flow reasons.
            res = format_test_error_1.formatTestError(error);
        }
        // Not all test results are arrays in order to be backwards compatible
        // with scripts that use a callback with test. Coerce results/errors to be arrays
        // and add the result options to each to be displayed
        const resArray = Array.isArray(res) ? res : [res];
        for (let i = 0; i < resArray.length; i++) {
            const pathWithOptionalProjectName = utils.getPathWithOptionalProjectName(path, resArray[i]);
            results.push(assign(resArray[i], { path: pathWithOptionalProjectName }));
            // currently testOpts are identical for each test result returned even if it's for multiple projects.
            // we want to return the project names, so will need to be crafty in a way that makes sense.
            if (!testOpts.projectNames) {
                resultOptions.push(testOpts);
            }
            else {
                resultOptions.push(assign(cloneDeep(testOpts), {
                    projectName: testOpts.projectNames[i],
                }));
            }
        }
    }
    const vulnerableResults = results.filter((res) => (res.vulnerabilities && res.vulnerabilities.length) ||
        (res.result &&
            res.result.cloudConfigResults &&
            res.result.cloudConfigResults.length));
    const errorResults = results.filter((res) => res instanceof Error);
    const notSuccess = errorResults.length > 0;
    const foundVulnerabilities = vulnerableResults.length > 0;
    // resultOptions is now an array of 1 or more options used for
    // the tests results is now an array of 1 or more test results
    // values depend on `options.json` value - string or object
    const mappedResults = !options.iac
        ? format_test_results_1.createErrorMappedResultsForJsonOutput(results)
        : results.map(iac_test_result_1.mapIacTestResult);
    const { stdout: dataToSend, stringifiedData, stringifiedJsonData, stringifiedSarifData, } = format_test_results_1.extractDataToSendFromResults(results, mappedResults, options);
    if (options.json || options.sarif) {
        // if all results are ok (.ok == true)
        if (mappedResults.every((res) => res.ok)) {
            return types_1.TestCommandResult.createJsonTestCommandResult(stringifiedData, stringifiedJsonData, stringifiedSarifData);
        }
        const err = new Error(stringifiedData);
        if (foundVulnerabilities) {
            if (options.failOn) {
                const fail = shouldFail(vulnerableResults, options.failOn);
                if (!fail) {
                    // return here to prevent failure
                    return types_1.TestCommandResult.createJsonTestCommandResult(stringifiedData, stringifiedJsonData, stringifiedSarifData);
                }
            }
            err.code = 'VULNS';
            const dataToSendNoVulns = dataToSend;
            delete dataToSendNoVulns.vulnerabilities;
            err.jsonNoVulns = dataToSendNoVulns;
        }
        if (notSuccess) {
            // Take the code of the first problem to go through error
            // translation.
            // Note: this is done based on the logic done below
            // for non-json/sarif outputs, where we take the code of
            // the first error.
            err.code = errorResults[0].code;
        }
        err.json = stringifiedData;
        err.jsonStringifiedResults = stringifiedJsonData;
        err.sarifStringifiedResults = stringifiedSarifData;
        throw err;
    }
    let response = results
        .map((result, i) => {
        return display_result_1.displayResult(results[i], resultOptions[i], result.foundProjectCount);
    })
        .join(`\n${SEPARATOR}`);
    if (notSuccess) {
        debug(`Failed to test ${errorResults.length} projects, errors:`);
        errorResults.forEach((err) => {
            const errString = err.stack ? err.stack.toString() : err.toString();
            debug('error: %s', errString);
        });
    }
    let summaryMessage = '';
    let errorResultsLength = errorResults.length;
    if (options.iac && iacScanFailures) {
        errorResultsLength = iacScanFailures.length || errorResults.length;
        for (const reason of iacScanFailures) {
            response += chalk_1.default.bold.red(iac_output_1.getIacDisplayErrorFileOutput(reason));
        }
    }
    if (results.length > 1) {
        const projects = results.length === 1 ? 'project' : 'projects';
        summaryMessage =
            `\n\n\nTested ${results.length} ${projects}` +
                formatters_1.summariseVulnerableResults(vulnerableResults, options) +
                formatters_1.summariseErrorResults(errorResultsLength) +
                '\n';
    }
    if (notSuccess) {
        response += chalk_1.default.bold.red(summaryMessage);
        const error = new Error(response);
        // take the code of the first problem to go through error
        // translation
        // HACK as there can be different errors, and we pass only the
        // first one
        error.code = errorResults[0].code;
        error.userMessage = errorResults[0].userMessage;
        error.strCode = errorResults[0].strCode;
        throw error;
    }
    if (foundVulnerabilities) {
        if (options.failOn) {
            const fail = shouldFail(vulnerableResults, options.failOn);
            if (!fail) {
                // return here to prevent throwing failure
                response += chalk_1.default.bold.green(summaryMessage);
                response += os_1.EOL + os_1.EOL;
                response += protect_update_notification_1.getProtectUpgradeWarningForPaths(packageJsonPathsWithSnykDepForProtect);
                return types_1.TestCommandResult.createHumanReadableTestCommandResult(response, stringifiedJsonData, stringifiedSarifData);
            }
        }
        response += chalk_1.default.bold.red(summaryMessage);
        response += os_1.EOL + os_1.EOL;
        const foundSpotlightVulnIds = spotlight_vuln_notification_1.containsSpotlightVulnIds(results);
        const spotlightVulnsMsg = spotlight_vuln_notification_1.notificationForSpotlightVulns(foundSpotlightVulnIds);
        response += spotlightVulnsMsg;
        const error = new Error(response);
        // take the code of the first problem to go through error
        // translation
        // HACK as there can be different errors, and we pass only the
        // first one
        error.code = vulnerableResults[0].code || 'VULNS';
        error.userMessage = vulnerableResults[0].userMessage;
        error.jsonStringifiedResults = stringifiedJsonData;
        error.sarifStringifiedResults = stringifiedSarifData;
        throw error;
    }
    response += chalk_1.default.bold.green(summaryMessage);
    response += os_1.EOL + os_1.EOL;
    response += protect_update_notification_1.getProtectUpgradeWarningForPaths(packageJsonPathsWithSnykDepForProtect);
    return types_1.TestCommandResult.createHumanReadableTestCommandResult(response, stringifiedJsonData, stringifiedSarifData);
}
exports.default = test;
function shouldFail(vulnerableResults, failOn) {
    // find reasons not to fail
    if (failOn === 'all') {
        return vuln_helpers_1.hasFixes(vulnerableResults);
    }
    if (failOn === 'upgradable') {
        return vuln_helpers_1.hasUpgrades(vulnerableResults);
    }
    if (failOn === 'patchable') {
        return vuln_helpers_1.hasPatches(vulnerableResults);
    }
    // should fail by default when there are vulnerable results
    return vulnerableResults.length > 0;
}


/***/ }),

/***/ 13285:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setDefaultTestOptions = void 0;
const config_1 = __webpack_require__(22541);
function setDefaultTestOptions(options) {
    const svpSupplied = (options['show-vulnerable-paths'] || '')
        .toString()
        .toLowerCase();
    delete options['show-vulnerable-paths'];
    return {
        ...options,
        // org fallback to config unless specified
        org: options.org || config_1.default.org,
        // making `show-vulnerable-paths` 'some' by default.
        showVulnPaths: showVulnPathsMapping[svpSupplied] || 'some',
    };
}
exports.setDefaultTestOptions = setDefaultTestOptions;
const showVulnPathsMapping = {
    false: 'none',
    none: 'none',
    true: 'some',
    some: 'some',
    all: 'all',
};


/***/ }),

/***/ 77978:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPathWithOptionalProjectName = void 0;
function getPathWithOptionalProjectName(currPath, testResult) {
    let projectName = testResult.projectName;
    if (projectName) {
        const index = projectName.indexOf('/');
        if (index > -1) {
            projectName = projectName.substr(index + 1);
        }
        else {
            projectName = undefined;
        }
    }
    const pathWithOptionalProjectName = projectName
        ? `${currPath}/${projectName}`
        : currPath;
    return pathWithOptionalProjectName;
}
exports.getPathWithOptionalProjectName = getPathWithOptionalProjectName;


/***/ }),

/***/ 4593:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateCredentials = void 0;
const api_token_1 = __webpack_require__(95181);
function validateCredentials(options) {
    try {
        api_token_1.apiTokenExists();
    }
    catch (err) {
        if (api_token_1.getOAuthToken()) {
            return;
        }
        else if (options.docker && api_token_1.getDockerToken()) {
            options.testDepGraphDockerEndpoint = '/docker-jwt/test-dependencies';
            options.isDockerUser = true;
        }
        else {
            throw err;
        }
    }
}
exports.validateCredentials = validateCredentials;


/***/ }),

/***/ 83476:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTestOptions = void 0;
const theme_1 = __webpack_require__(86988);
const common_1 = __webpack_require__(53110);
const fail_on_error_ts_1 = __webpack_require__(18195);
function validateTestOptions(options) {
    if (options.severityThreshold &&
        !validateSeverityThreshold(options.severityThreshold)) {
        throw new Error('INVALID_SEVERITY_THRESHOLD');
    }
    if (options.failOn && !validateFailOn(options.failOn)) {
        const error = new fail_on_error_ts_1.FailOnError();
        throw theme_1.color.status.error(error.message);
    }
}
exports.validateTestOptions = validateTestOptions;
function validateSeverityThreshold(severityThreshold) {
    return common_1.SEVERITIES.map((s) => s.verboseName).indexOf(severityThreshold) > -1;
}
function validateFailOn(arg) {
    return Object.keys(common_1.FAIL_ON).includes(arg);
}


/***/ }),

/***/ 18195:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FailOnError = void 0;
const custom_error_1 = __webpack_require__(17188);
const common_1 = __webpack_require__(53110);
class FailOnError extends custom_error_1.CustomError {
    constructor() {
        super(FailOnError.ERROR_MESSAGE);
    }
}
exports.FailOnError = FailOnError;
FailOnError.ERROR_MESSAGE = 'Invalid fail on argument, please use one of: ' +
    Object.keys(common_1.FAIL_ON).join(' | ');


/***/ }),

/***/ 9401:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLevel = exports.getResults = exports.getRules = exports.createSarifOutputForOpenSource = void 0;
const upperFirst = __webpack_require__(90039);
const groupBy = __webpack_require__(20276);
const map = __webpack_require__(80820);
const legacy_1 = __webpack_require__(34013);
const LOCK_FILES_TO_MANIFEST_MAP = {
    'Gemfile.lock': 'Gemfile',
    'package-lock.json': 'package.json',
    'yarn.lock': 'package.json',
    'Gopkg.lock': 'Gopkg.toml',
    'go.sum': 'go.mod',
    'composer.lock': 'composer.json',
    'Podfile.lock': 'Podfile',
    'poetry.lock': 'pyproject.toml',
};
function createSarifOutputForOpenSource(testResults) {
    return {
        $schema: 'https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json',
        version: '2.1.0',
        runs: testResults.map(replaceLockfileWithManifest).map((testResult) => ({
            tool: {
                driver: {
                    name: 'Snyk Open Source',
                    rules: getRules(testResult),
                },
            },
            results: getResults(testResult),
        })),
    };
}
exports.createSarifOutputForOpenSource = createSarifOutputForOpenSource;
function replaceLockfileWithManifest(testResult) {
    let targetFile = testResult.displayTargetFile || '';
    for (const [key, replacer] of Object.entries(LOCK_FILES_TO_MANIFEST_MAP)) {
        targetFile = targetFile.replace(new RegExp(key, 'g'), replacer);
    }
    return {
        ...testResult,
        vulnerabilities: testResult.vulnerabilities || [],
        displayTargetFile: targetFile,
    };
}
function getRules(testResult) {
    const groupedVulnerabilities = groupBy(testResult.vulnerabilities, 'id');
    return map(groupedVulnerabilities, ([vuln, ...moreVulns]) => {
        var _a, _b, _c;
        const cves = (_b = (_a = vuln.identifiers) === null || _a === void 0 ? void 0 : _a.CVE) === null || _b === void 0 ? void 0 : _b.join();
        return {
            id: vuln.id,
            shortDescription: {
                text: `${upperFirst(vuln.severity)} severity - ${vuln.title} vulnerability in ${vuln.packageName}`,
            },
            fullDescription: {
                text: cves
                    ? `(${cves}) ${vuln.name}@${vuln.version}`
                    : `${vuln.name}@${vuln.version}`,
            },
            help: {
                text: '',
                markdown: `* Package Manager: ${testResult.packageManager}
* ${vuln.type === 'license' ? 'Module' : 'Vulnerable module'}: ${vuln.name}
* Introduced through: ${getIntroducedThrough(vuln)}
#### Detailed paths
${[vuln, ...moreVulns]
                    .map((item) => `* _Introduced through_: ${item.from.join(' › ')}`)
                    .join('\n')}
${vuln.description}`.replace(/##\s/g, '# '),
            },
            properties: {
                tags: [
                    'security',
                    ...(((_c = vuln.identifiers) === null || _c === void 0 ? void 0 : _c.CWE) || []),
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    testResult.packageManager,
                ],
            },
        };
    });
}
exports.getRules = getRules;
function getResults(testResult) {
    const groupedVulnerabilities = groupBy(testResult.vulnerabilities, 'id');
    return map(groupedVulnerabilities, ([vuln]) => ({
        ruleId: vuln.id,
        level: getLevel(vuln),
        message: {
            text: `This file introduces a vulnerable ${vuln.packageName} package with a ${vuln.severity} severity vulnerability.`,
        },
        locations: [
            {
                physicalLocation: {
                    artifactLocation: {
                        uri: testResult.displayTargetFile,
                    },
                    region: {
                        startLine: vuln.lineNumber || 1,
                    },
                },
            },
        ],
    }));
}
exports.getResults = getResults;
function getLevel(vuln) {
    switch (vuln.severity) {
        case legacy_1.SEVERITY.CRITICAL:
        case legacy_1.SEVERITY.HIGH:
            return 'error';
        case legacy_1.SEVERITY.MEDIUM:
            return 'warning';
        case legacy_1.SEVERITY.LOW:
        default:
            return 'note';
    }
}
exports.getLevel = getLevel;
function getIntroducedThrough(vuln) {
    const [firstFrom, secondFrom] = vuln.from || [];
    return vuln.from.length > 2
        ? `${firstFrom}, ${secondFrom} and others`
        : vuln.from.length === 2
            ? `${firstFrom} and ${secondFrom}`
            : firstFrom;
}


/***/ }),

/***/ 30417:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showFixTip = void 0;
const chalk_1 = __webpack_require__(32589);
const detect_1 = __webpack_require__(45318);
function showFixTip(projectType, res, options) {
    const snykFixSupported = ['pip', 'poetry'];
    if (!snykFixSupported.includes(projectType) || !detect_1.isLocalFolder(options.path)) {
        return '';
    }
    if (!res.ok && res.vulnerabilities.length > 0) {
        return (`Tip: Try ${chalk_1.default.bold('`snyk fix`')} to address these issues.${chalk_1.default.bold('`snyk fix`')} is a new CLI command in that aims to automatically apply the recommended updates for supported ecosystems.` +
            '\nSee documentation on how to enable this beta feature: https://docs.snyk.io/features/snyk-cli/fix-vulnerabilities-from-the-cli/automatic-remediation-with-snyk-fix');
    }
    return '';
}
exports.showFixTip = showFixTip;


/***/ }),

/***/ 89667:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.displayResult = void 0;
const chalk_1 = __webpack_require__(32589);
const theme_1 = __webpack_require__(86988);
const is_ci_1 = __webpack_require__(10090);
const detect_1 = __webpack_require__(45318);
const formatters_1 = __webpack_require__(81329);
const iac_output_1 = __webpack_require__(26188);
const constants_1 = __webpack_require__(68620);
const format_test_results_1 = __webpack_require__(59744);
const show_multi_scan_tip_1 = __webpack_require__(95100);
function displayResult(res, options, foundProjectCount) {
    const meta = formatters_1.formatTestMeta(res, options);
    const dockerAdvice = formatters_1.dockerRemediationForDisplay(res);
    const projectType = res.packageManager || options.packageManager;
    const localPackageTest = detect_1.isLocalFolder(options.path);
    let testingPath = options.path;
    if (options.iac && res.targetFile) {
        testingPath = res.targetFile;
    }
    const prefix = chalk_1.default.bold.white('\nTesting ' + testingPath + '...\n\n');
    // handle errors by extracting their message
    if (res instanceof Error) {
        return prefix + res.message;
    }
    const issuesText = res.licensesPolicy ||
        constants_1.TEST_SUPPORTED_IAC_PROJECTS.includes(projectType)
        ? 'issues'
        : 'vulnerabilities';
    let pathOrDepsText = '';
    if (res.dependencyCount) {
        pathOrDepsText += res.dependencyCount + ' dependencies';
    }
    else if (options.iac && res.targetFile) {
        pathOrDepsText += res.targetFile;
    }
    else {
        pathOrDepsText += options.path;
    }
    const testedInfoText = `Tested ${pathOrDepsText} for known ${issuesText}`;
    const multiProjectTip = show_multi_scan_tip_1.showMultiScanTip(projectType, options, foundProjectCount);
    const multiProjAdvice = multiProjectTip ? `\n\n${multiProjectTip}` : '';
    // OK  => no vulns found, return
    if (res.ok && res.vulnerabilities.length === 0) {
        const vulnPathsText = options.showVulnPaths
            ? 'no vulnerable paths found.'
            : 'none were found.';
        const summaryOKText = theme_1.color.status.success(`${theme_1.icon.VALID} ${testedInfoText}, ${vulnPathsText}`);
        const nextStepsText = localPackageTest
            ? '\n\nNext steps:' +
                '\n- Run `snyk monitor` to be notified ' +
                'about new related vulnerabilities.' +
                '\n- Run `snyk test` as part of ' +
                'your CI/test.'
            : '';
        // user tested a package@version and got 0 vulns back, but there were dev deps
        // to consider
        // to consider
        const snykPackageTestTip = !(options.docker ||
            localPackageTest ||
            options.dev)
            ? '\n\nTip: Snyk only tests production dependencies by default. You can try re-running with the `--dev` flag.'
            : '';
        const dockerCTA = format_test_results_1.dockerUserCTA(options);
        return (prefix +
            meta +
            '\n\n' +
            summaryOKText +
            multiProjAdvice +
            (is_ci_1.isCI()
                ? ''
                : dockerAdvice + nextStepsText + snykPackageTestTip + dockerCTA));
    }
    if (constants_1.TEST_SUPPORTED_IAC_PROJECTS.includes(res.packageManager)) {
        return iac_output_1.getIacDisplayedOutput(res, testedInfoText, meta, prefix);
    }
    // NOT OK => We found some vulns, let's format the vulns info
    return format_test_results_1.getDisplayedOutput(res, options, testedInfoText, localPackageTest, projectType, meta, prefix, multiProjAdvice, dockerAdvice);
}
exports.displayResult = displayResult;


/***/ }),

/***/ 59744:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.groupVulnerabilities = exports.dockerUserCTA = exports.getDisplayedOutput = exports.createErrorMappedResultsForJsonOutput = exports.extractDataToSendFromResults = void 0;
const format_reachability_1 = __webpack_require__(13331);
const chalk_1 = __webpack_require__(32589);
const config_1 = __webpack_require__(22541);
const cloneDeep = __webpack_require__(83465);
const orderBy = __webpack_require__(75316);
const analytics = __webpack_require__(82744);
const remediation_based_format_issues_1 = __webpack_require__(57995);
const legacy_format_issue_1 = __webpack_require__(63540);
const docker_1 = __webpack_require__(41287);
const sarif_output_1 = __webpack_require__(5034);
const iac_output_1 = __webpack_require__(26188);
const vuln_helpers_1 = __webpack_require__(14784);
const json_1 = __webpack_require__(27019);
const open_source_sarif_output_1 = __webpack_require__(9401);
const get_severity_value_1 = __webpack_require__(24898);
const show_fix_tip_1 = __webpack_require__(30417);
const dist_1 = __webpack_require__(61165);
function createJsonResultOutput(jsonResult, options) {
    const jsonResultClone = cloneDeep(jsonResult);
    delete jsonResultClone.scanResult;
    formatJsonVulnerabilityStructure(jsonResultClone, options);
    return jsonResultClone;
}
function formatJsonVulnerabilityStructure(jsonResult, options) {
    if (options['group-issues']) {
        jsonResult.vulnerabilities = Object.values((jsonResult.vulnerabilities || []).reduce((acc, vuln) => {
            var _a, _b;
            vuln.from = [vuln.from].concat(((_a = acc[vuln.id]) === null || _a === void 0 ? void 0 : _a.from) || []);
            vuln.name = [vuln.name].concat(((_b = acc[vuln.id]) === null || _b === void 0 ? void 0 : _b.name) || []);
            acc[vuln.id] = vuln;
            return acc;
        }, {}));
    }
    if (jsonResult.vulnerabilities) {
        jsonResult.vulnerabilities.forEach((vuln) => {
            if (vuln.reachability) {
                vuln.reachability = format_reachability_1.getReachabilityJson(vuln.reachability);
            }
        });
    }
}
function extractDataToSendFromResults(results, mappedResults, options) {
    let sarifData = {};
    let stringifiedSarifData = '';
    if (options.sarif || options['sarif-file-output']) {
        if (options.iac) {
            sarifData = iac_output_1.createSarifOutputForIac(results);
        }
        else if (options.docker) {
            sarifData = sarif_output_1.createSarifOutputForContainers(results);
        }
        else {
            sarifData = open_source_sarif_output_1.createSarifOutputForOpenSource(results);
        }
        stringifiedSarifData = json_1.jsonStringifyLargeObject(sarifData);
    }
    const jsonResults = mappedResults.map((res) => createJsonResultOutput(res, options));
    // backwards compat - strip array IFF only one result
    const jsonData = jsonResults.length === 1 ? jsonResults[0] : jsonResults;
    let stringifiedJsonData = '';
    if (options.json || options['json-file-output']) {
        stringifiedJsonData = json_1.jsonStringifyLargeObject(jsonData);
    }
    const dataToSend = options.sarif ? sarifData : jsonData;
    const stringifiedData = options.sarif
        ? stringifiedSarifData
        : stringifiedJsonData;
    return {
        stdout: dataToSend,
        stringifiedData,
        stringifiedJsonData,
        stringifiedSarifData,
    };
}
exports.extractDataToSendFromResults = extractDataToSendFromResults;
function createErrorMappedResultsForJsonOutput(results) {
    const errorMappedResults = results.map((result) => {
        // add json for when thrown exception
        if (result instanceof Error) {
            return {
                ok: false,
                error: result.message,
                path: result.path,
            };
        }
        return result;
    });
    return errorMappedResults;
}
exports.createErrorMappedResultsForJsonOutput = createErrorMappedResultsForJsonOutput;
function getDisplayedOutput(res, options, testedInfoText, localPackageTest, projectType, meta, prefix, multiProjAdvice, dockerAdvice) {
    var _a;
    const vulnCount = res.vulnerabilities && res.vulnerabilities.length;
    const singleVulnText = res.licensesPolicy ? 'issue' : 'vulnerability';
    const multipleVulnsText = res.licensesPolicy ? 'issues' : 'vulnerabilities';
    // Text will look like so:
    // 'found 232 vulnerabilities, 404 vulnerable paths.'
    let vulnCountText = `found ${res.uniqueCount} ` +
        (res.uniqueCount === 1 ? singleVulnText : multipleVulnsText);
    // Docker is currently not supported as num of paths is inaccurate due to trimming of paths to reduce size.
    if (options.showVulnPaths && !options.docker) {
        vulnCountText += `, ${vulnCount} vulnerable `;
        if (vulnCount === 1) {
            vulnCountText += 'path.';
        }
        else {
            vulnCountText += 'paths.';
        }
    }
    else {
        vulnCountText += '.';
    }
    const reachableVulnsText = options.reachableVulns && vulnCount > 0
        ? ` ${format_reachability_1.summariseReachableVulns(res.vulnerabilities)}`
        : '';
    const summary = testedInfoText +
        ', ' +
        chalk_1.default.red.bold(vulnCountText) +
        chalk_1.default.blue.bold(reachableVulnsText);
    const fixTip = show_fix_tip_1.showFixTip(projectType, res, options);
    const fixAdvice = fixTip ? `\n\n${fixTip}` : '';
    const dockerfileWarning = getDockerfileWarning(res.scanResult);
    const dockerSuggestion = getDockerSuggestionText(options, config_1.default, (_a = res === null || res === void 0 ? void 0 : res.docker) === null || _a === void 0 ? void 0 : _a.baseImage);
    const dockerDocsLink = getDockerRemediationDocsLink(dockerAdvice, config_1.default);
    const vulns = res.vulnerabilities || [];
    const groupedVulns = groupVulnerabilities(vulns);
    const sortedGroupedVulns = orderBy(groupedVulns, ['metadata.severityValue', 'metadata.name'], ['asc', 'desc']);
    const filteredSortedGroupedVulns = sortedGroupedVulns.filter((vuln) => vuln.metadata.packageManager !== 'upstream');
    const binariesSortedGroupedVulns = sortedGroupedVulns.filter((vuln) => vuln.metadata.packageManager === 'upstream');
    let groupedVulnInfoOutput;
    if (res.remediation) {
        analytics.add('actionableRemediation', true);
        groupedVulnInfoOutput = remediation_based_format_issues_1.formatIssuesWithRemediation(filteredSortedGroupedVulns, res.remediation, options);
    }
    else {
        analytics.add('actionableRemediation', false);
        groupedVulnInfoOutput = filteredSortedGroupedVulns.map((vuln) => legacy_format_issue_1.formatIssues(vuln, options));
    }
    const groupedDockerBinariesVulnInfoOutput = res.docker && binariesSortedGroupedVulns.length
        ? docker_1.formatDockerBinariesIssues(binariesSortedGroupedVulns, res.docker.binariesVulns, options)
        : [];
    let body = groupedVulnInfoOutput.join('\n\n') +
        '\n\n' +
        groupedDockerBinariesVulnInfoOutput.join('\n\n') +
        '\n\n' +
        meta;
    if (res.remediation) {
        body = summary + body + fixAdvice;
    }
    else {
        body = body + '\n\n' + summary + fixAdvice;
    }
    const ignoredIssues = '';
    const dockerCTA = dockerUserCTA(options);
    return (prefix +
        body +
        multiProjAdvice +
        ignoredIssues +
        dockerAdvice +
        dockerfileWarning +
        dockerSuggestion +
        dockerDocsLink +
        dockerCTA);
}
exports.getDisplayedOutput = getDisplayedOutput;
function dockerUserCTA(options) {
    if (options.isDockerUser) {
        return '\n\nFor more free scans that keep your images secure, sign up to Snyk at https://dockr.ly/3ePqVcp';
    }
    return '';
}
exports.dockerUserCTA = dockerUserCTA;
function getDockerSuggestionText(options, config, baseImageRes) {
    if (!options.docker || options.isDockerUser) {
        return '';
    }
    let dockerSuggestion = '';
    if (config && config.disableSuggestions !== 'true') {
        const optOutSuggestions = '\n\nTo remove this message in the future, please run `snyk config set disableSuggestions=true`';
        if (!options.file) {
            if (!baseImageRes) {
                dockerSuggestion +=
                    chalk_1.default.bold.white('\n\nSnyk wasn’t able to auto detect the base image, use `--file` option to get base image remediation advice.' +
                        `\nExample: $ snyk container test ${options.path} --file=path/to/Dockerfile`) + optOutSuggestions;
            }
        }
        else if (!options['exclude-base-image-vulns']) {
            dockerSuggestion +=
                chalk_1.default.bold.white('\n\nPro tip: use `--exclude-base-image-vulns` to exclude from display Docker base image vulnerabilities.') + optOutSuggestions;
        }
    }
    return dockerSuggestion;
}
function getDockerfileWarning(scanResult) {
    if (!scanResult) {
        return '';
    }
    const fact = scanResult.facts.find((fact) => fact.type === 'dockerfileAnalysis');
    if (!fact) {
        return '';
    }
    const dockerfileAnalysisFact = fact;
    if (!dockerfileAnalysisFact.data.error) {
        return '';
    }
    let userMessage = chalk_1.default.yellow('\n\nWarning: Unable to analyse Dockerfile provided through `--file`.');
    switch (dockerfileAnalysisFact.data.error.code) {
        case dist_1.DockerFileAnalysisErrorCode.BASE_IMAGE_NAME_NOT_FOUND:
            userMessage += chalk_1.default.yellow('\n         Dockerfile must begin with a FROM instruction. This may be after parser directives, comments, and globally scoped ARGs.');
            break;
        case dist_1.DockerFileAnalysisErrorCode.BASE_IMAGE_NON_RESOLVABLE:
            userMessage += chalk_1.default.yellow('\n         Dockerfile must have default values for all ARG instructions.');
            break;
    }
    return userMessage;
}
function getDockerRemediationDocsLink(dockerAdvice, config) {
    if (config.disableSuggestions === 'true' || dockerAdvice.length === 0) {
        return '';
    }
    return (chalk_1.default.white('\n\nLearn more: ') +
        chalk_1.default.white.underline('https://docs.snyk.io/products/snyk-container/getting-around-the-snyk-container-ui/base-image-detection'));
}
function groupVulnerabilities(vulns) {
    return vulns.reduce((map, curr) => {
        if (!map[curr.id]) {
            map[curr.id] = {};
            map[curr.id].list = [];
            map[curr.id].metadata = metadataForVuln(curr);
            map[curr.id].isIgnored = false;
            map[curr.id].isPatched = false;
            // Extra added fields for ease of handling
            map[curr.id].title = curr.title;
            map[curr.id].note = curr.note;
            map[curr.id].severity = curr.severity;
            map[curr.id].originalSeverity = curr.originalSeverity;
            map[curr.id].isNew = vuln_helpers_1.isNewVuln(curr);
            map[curr.id].name = curr.name;
            map[curr.id].version = curr.version;
            map[curr.id].fixedIn = curr.fixedIn;
            map[curr.id].dockerfileInstruction = curr.dockerfileInstruction;
            map[curr.id].dockerBaseImage = curr.dockerBaseImage;
            map[curr.id].nearestFixedInVersion = curr.nearestFixedInVersion;
            map[curr.id].legalInstructionsArray = curr.legalInstructionsArray;
            map[curr.id].reachability = curr.reachability;
        }
        map[curr.id].list.push(curr);
        if (!map[curr.id].isFixable) {
            map[curr.id].isFixable = vuln_helpers_1.isVulnFixable(curr);
        }
        if (!map[curr.id].note) {
            map[curr.id].note = !!curr.note;
        }
        return map;
    }, {});
}
exports.groupVulnerabilities = groupVulnerabilities;
function metadataForVuln(vuln) {
    return {
        id: vuln.id,
        title: vuln.title,
        description: vuln.description,
        type: vuln.type,
        name: vuln.name,
        info: vuln.info,
        severity: vuln.severity,
        severityValue: get_severity_value_1.getSeverityValue(vuln.severity),
        isNew: vuln_helpers_1.isNewVuln(vuln),
        version: vuln.version,
        packageManager: vuln.packageManager,
    };
}


/***/ }),

/***/ 79304:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPackageJsonPathsContainingSnykDependency = exports.checkPackageJsonForSnykDependency = exports.packageJsonFileExistsInDirectory = exports.getProtectUpgradeWarningForPaths = void 0;
const os_1 = __webpack_require__(12087);
const theme = __webpack_require__(86988);
const fs = __webpack_require__(35747);
const path = __webpack_require__(85622);
const createDebug = __webpack_require__(15158);
const debug = createDebug('snyk-protect-update-notification');
function getProtectUpgradeWarningForPaths(packageJsonPaths) {
    try {
        if ((packageJsonPaths === null || packageJsonPaths === void 0 ? void 0 : packageJsonPaths.length) > 0) {
            let message = theme.color.status.warn(`${theme.icon.WARNING} WARNING: It looks like you have the \`snyk\` dependency in the \`package.json\` file(s) at the following path(s):` +
                os_1.EOL);
            packageJsonPaths.forEach((p) => {
                message += theme.color.status.warn(`  - ${p}` + os_1.EOL);
            });
            const githubReadmeUrlShort = 'https://snyk.co/ud1cR'; // https://github.com/snyk/snyk/tree/master/packages/snyk-protect#migrating-from-snyk-protect-to-snykprotect
            message += theme.color.status.warn(`For more information and migration instructions, see ${githubReadmeUrlShort}` +
                os_1.EOL);
            return message;
        }
        else {
            return '';
        }
    }
    catch (e) {
        debug('Error in getProtectUpgradeWarningForPaths()', e);
        return '';
    }
}
exports.getProtectUpgradeWarningForPaths = getProtectUpgradeWarningForPaths;
function packageJsonFileExistsInDirectory(directoryPath) {
    try {
        const packageJsonPath = path.resolve(directoryPath, 'package.json');
        const fileExists = fs.existsSync(packageJsonPath);
        return fileExists;
    }
    catch (e) {
        debug('Error in packageJsonFileExistsInDirectory()', e);
        return false;
    }
}
exports.packageJsonFileExistsInDirectory = packageJsonFileExistsInDirectory;
function checkPackageJsonForSnykDependency(packageJsonPath) {
    try {
        const fileExists = fs.existsSync(packageJsonPath);
        if (fileExists) {
            const packageJson = fs.readFileSync(packageJsonPath, 'utf8');
            const packageJsonObject = JSON.parse(packageJson);
            const snykDependency = packageJsonObject.dependencies['snyk'];
            if (snykDependency) {
                return true;
            }
        }
    }
    catch (e) {
        debug('Error in checkPackageJsonForSnykDependency()', e);
    }
    return false;
}
exports.checkPackageJsonForSnykDependency = checkPackageJsonForSnykDependency;
function getPackageJsonPathsContainingSnykDependency(fileOption, paths) {
    const packageJsonPathsWithSnykDepForProtect = [];
    try {
        if (fileOption) {
            if (fileOption.endsWith('package.json') ||
                fileOption.endsWith('package-lock.json')) {
                const directoryWithPackageJson = path.dirname(fileOption);
                if (packageJsonFileExistsInDirectory(directoryWithPackageJson)) {
                    const packageJsonPath = path.resolve(directoryWithPackageJson, 'package.json');
                    const packageJsonContainsSnykDep = checkPackageJsonForSnykDependency(packageJsonPath);
                    if (packageJsonContainsSnykDep) {
                        packageJsonPathsWithSnykDepForProtect.push(packageJsonPath);
                    }
                }
            }
        }
        else {
            paths.forEach((testPath) => {
                if (packageJsonFileExistsInDirectory(testPath)) {
                    const packageJsonPath = path.resolve(testPath, 'package.json');
                    const packageJsonContainsSnykDep = checkPackageJsonForSnykDependency(packageJsonPath);
                    if (packageJsonContainsSnykDep) {
                        packageJsonPathsWithSnykDepForProtect.push(packageJsonPath);
                    }
                }
            });
        }
    }
    catch (e) {
        debug('Error in getPackageJsonPathsContainingSnykDependency()', e);
    }
    return packageJsonPathsWithSnykDepForProtect;
}
exports.getPackageJsonPathsContainingSnykDependency = getPackageJsonPathsContainingSnykDependency;


/***/ }),

/***/ 46816:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapIacIssue = exports.mapIacTestResult = void 0;
const IAC_ISSUES_KEY = 'infrastructureAsCodeIssues';
function mapIacTestResult(iacTest) {
    var _a;
    if (iacTest instanceof Error) {
        return {
            ok: false,
            error: iacTest.message,
            path: iacTest.path,
        };
    }
    const infrastructureAsCodeIssues = ((_a = iacTest === null || iacTest === void 0 ? void 0 : iacTest.result) === null || _a === void 0 ? void 0 : _a.cloudConfigResults.map(mapIacIssue)) || [];
    const { result: { projectType }, ...filteredIacTest } = iacTest;
    return {
        ...filteredIacTest,
        projectType,
        ok: infrastructureAsCodeIssues.length === 0,
        [IAC_ISSUES_KEY]: infrastructureAsCodeIssues,
    };
}
exports.mapIacTestResult = mapIacTestResult;
function mapIacIssue(iacIssue) {
    // filters out & renames properties we're getting from registry and don't need for the JSON output.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { cloudConfigPath: path, name, from, ...mappedIacIssue } = iacIssue;
    return { ...mappedIacIssue, path };
}
exports.mapIacIssue = mapIacIssue;


/***/ }),

/***/ 24083:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notificationForSpotlightVulns = exports.containsSpotlightVulnIds = void 0;
const theme = __webpack_require__(86988);
const createDebug = __webpack_require__(15158);
const os_1 = __webpack_require__(12087);
const debug = createDebug('snyk-spotlight-vuln-notification');
const spotlightVulnIds = ['SNYK-JAVA-ORGAPACHELOGGINGLOG4J-2314720'];
function containsSpotlightVulnIds(results) {
    try {
        const spotlightVulnsFound = new Set();
        for (const r of results) {
            if (r.vulnerabilities) {
                for (const v of r.vulnerabilities) {
                    if (spotlightVulnIds.includes(v.id)) {
                        spotlightVulnsFound.add(v.id);
                    }
                }
            }
        }
        return [...spotlightVulnsFound];
    }
    catch (err) {
        debug('Error in containsSpotlightVulnIds()', err);
        return [];
    }
}
exports.containsSpotlightVulnIds = containsSpotlightVulnIds;
function notificationForSpotlightVulns(foundSpotlightVulnsIds) {
    try {
        if (foundSpotlightVulnsIds.length > 0) {
            let message = '';
            for (const vulnId of spotlightVulnIds) {
                if (vulnId === 'SNYK-JAVA-ORGAPACHELOGGINGLOG4J-2314720') {
                    message += theme.color.severity.critical(`${theme.icon.WARNING} WARNING: Critical severity vulnerabilities were found with Log4j!` +
                        os_1.EOL);
                    for (const vulnId of foundSpotlightVulnsIds) {
                        message += `  - ${vulnId} (See https://snyk.io/vuln/${vulnId})`;
                    }
                    message += os_1.EOL + os_1.EOL;
                    message +=
                        theme.color.severity.critical(`We highly recommend fixing this vulnerability. If it cannot be fixed by upgrading, see mitigation information here:`) +
                            os_1.EOL +
                            '  - https://security.snyk.io/vuln/SNYK-JAVA-ORGAPACHELOGGINGLOG4J-2314720' +
                            os_1.EOL +
                            '  - https://snyk.io/blog/log4shell-remediation-cheat-sheet/' +
                            os_1.EOL;
                }
            }
            return message;
        }
        return '';
    }
    catch (err) {
        debug('Error in notificationForSpotlightVulns()', err);
        return '';
    }
}
exports.notificationForSpotlightVulns = notificationForSpotlightVulns;


/***/ }),

/***/ 14784:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVulnFixable = exports.isVulnPatchable = exports.isVulnUpgradable = exports.hasPatches = exports.isPatchable = exports.hasUpgrades = exports.isUpgradable = exports.hasFixes = exports.isFixable = exports.isNewVuln = void 0;
// check if vuln was published in the last month
function isNewVuln(vuln) {
    const MONTH = 30 * 24 * 60 * 60 * 1000;
    const publicationTime = new Date(vuln.publicationTime).getTime();
    return publicationTime > Date.now() - MONTH;
}
exports.isNewVuln = isNewVuln;
function isFixable(testResult) {
    return isUpgradable(testResult) || isPatchable(testResult);
}
exports.isFixable = isFixable;
function hasFixes(testResults) {
    return testResults.some(isFixable);
}
exports.hasFixes = hasFixes;
function isUpgradable(testResult) {
    if (testResult.remediation) {
        const { remediation: { upgrade = {}, pin = {} }, } = testResult;
        return Object.keys(upgrade).length > 0 || Object.keys(pin).length > 0;
    }
    // if remediation is not available, fallback on vuln properties
    const { vulnerabilities = {} } = testResult;
    return vulnerabilities.some(isVulnUpgradable);
}
exports.isUpgradable = isUpgradable;
function hasUpgrades(testResults) {
    return testResults.some(isUpgradable);
}
exports.hasUpgrades = hasUpgrades;
function isPatchable(testResult) {
    if (testResult.remediation) {
        const { remediation: { patch = {} }, } = testResult;
        return Object.keys(patch).length > 0;
    }
    // if remediation is not available, fallback on vuln properties
    const { vulnerabilities = {} } = testResult;
    return vulnerabilities.some(isVulnPatchable);
}
exports.isPatchable = isPatchable;
function hasPatches(testResults) {
    return testResults.some(isPatchable);
}
exports.hasPatches = hasPatches;
function isVulnUpgradable(vuln) {
    return vuln.isUpgradable || vuln.isPinnable;
}
exports.isVulnUpgradable = isVulnUpgradable;
function isVulnPatchable(vuln) {
    return vuln.isPatchable;
}
exports.isVulnPatchable = isVulnPatchable;
function isVulnFixable(vuln) {
    return isVulnUpgradable(vuln) || isVulnPatchable(vuln);
}
exports.isVulnFixable = isVulnFixable;


/***/ })

};
;
//# sourceMappingURL=917.index.js.map