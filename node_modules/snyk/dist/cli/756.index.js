"use strict";
exports.id = 756;
exports.ids = [756];
exports.modules = {

/***/ 21766:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


const path = __webpack_require__(85622);
const os = __webpack_require__(12087);

const homedir = os.homedir();
const tmpdir = os.tmpdir();
const {env} = process;

const macos = name => {
	const library = path.join(homedir, 'Library');

	return {
		data: path.join(library, 'Application Support', name),
		config: path.join(library, 'Preferences', name),
		cache: path.join(library, 'Caches', name),
		log: path.join(library, 'Logs', name),
		temp: path.join(tmpdir, name)
	};
};

const windows = name => {
	const appData = env.APPDATA || path.join(homedir, 'AppData', 'Roaming');
	const localAppData = env.LOCALAPPDATA || path.join(homedir, 'AppData', 'Local');

	return {
		// Data/config/cache/log are invented by me as Windows isn't opinionated about this
		data: path.join(localAppData, name, 'Data'),
		config: path.join(appData, name, 'Config'),
		cache: path.join(localAppData, name, 'Cache'),
		log: path.join(localAppData, name, 'Log'),
		temp: path.join(tmpdir, name)
	};
};

// https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
const linux = name => {
	const username = path.basename(homedir);

	return {
		data: path.join(env.XDG_DATA_HOME || path.join(homedir, '.local', 'share'), name),
		config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, '.config'), name),
		cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, '.cache'), name),
		// https://wiki.debian.org/XDGBaseDirectorySpecification#state
		log: path.join(env.XDG_STATE_HOME || path.join(homedir, '.local', 'state'), name),
		temp: path.join(tmpdir, username, name)
	};
};

const envPaths = (name, options) => {
	if (typeof name !== 'string') {
		throw new TypeError(`Expected string, got ${typeof name}`);
	}

	options = Object.assign({suffix: 'nodejs'}, options);

	if (options.suffix) {
		// Add suffix to prevent possible conflict with native apps
		name += `-${options.suffix}`;
	}

	if (process.platform === 'darwin') {
		return macos(name);
	}

	if (process.platform === 'win32') {
		return windows(name);
	}

	return linux(name);
};

module.exports = envPaths;
// TODO: Remove this for the next major release
module.exports.default = envPaths;


/***/ }),

/***/ 32731:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const process_command_args_1 = __webpack_require__(52369);
const drift_1 = __webpack_require__(26445);
const assert_iac_options_flag_1 = __webpack_require__(68590);
const measurable_methods_1 = __webpack_require__(78272);
const config_1 = __webpack_require__(22541);
const legacyError = __webpack_require__(79407);
async function drift(...args) {
    var _a, _b;
    const { options, paths } = process_command_args_1.processCommandArgs(...args);
    if (options.iac != true) {
        return legacyError('drift');
    }
    const orgPublicId = (_a = options.org) !== null && _a !== void 0 ? _a : config_1.default.org;
    const iacOrgSettings = await measurable_methods_1.getIacOrgSettings(orgPublicId);
    if (!((_b = iacOrgSettings.entitlements) === null || _b === void 0 ? void 0 : _b.iacDrift)) {
        throw new assert_iac_options_flag_1.UnsupportedEntitlementCommandError('drift', 'iacDrift');
    }
    try {
        const args = drift_1.parseArgs(paths, options);
        const ret = await drift_1.driftctl(args);
        process.exit(ret);
    }
    catch (e) {
        const err = new Error('Error running `iac drift` ' + e);
        return Promise.reject(err);
    }
}
exports.default = drift;


/***/ }),

/***/ 52369:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processCommandArgs = void 0;
function processCommandArgs(...args) {
    let options = {};
    if (typeof args[args.length - 1] === 'object') {
        options = args.pop();
    }
    args = args.filter(Boolean);
    // For repository scanning, populate with default path (cwd) if no path given
    if (args.length === 0 && !options.docker) {
        args.unshift(process.cwd());
    }
    return { options, paths: args };
}
exports.processCommandArgs = processCommandArgs;


/***/ }),

/***/ 68620:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.projectTypeByFileType = exports.TEST_SUPPORTED_IAC_PROJECTS = exports.IacProjectType = void 0;
var IacProjectType;
(function (IacProjectType) {
    IacProjectType["K8S"] = "k8sconfig";
    IacProjectType["TERRAFORM"] = "terraformconfig";
    IacProjectType["CLOUDFORMATION"] = "cloudformationconfig";
    IacProjectType["ARM"] = "armconfig";
    IacProjectType["CUSTOM"] = "customconfig";
    IacProjectType["MULTI_IAC"] = "multiiacconfig";
})(IacProjectType = exports.IacProjectType || (exports.IacProjectType = {}));
exports.TEST_SUPPORTED_IAC_PROJECTS = [
    IacProjectType.K8S,
    IacProjectType.TERRAFORM,
    IacProjectType.CLOUDFORMATION,
    IacProjectType.ARM,
    IacProjectType.MULTI_IAC,
    IacProjectType.CUSTOM,
];
exports.projectTypeByFileType = {
    yaml: IacProjectType.K8S,
    yml: IacProjectType.K8S,
    json: IacProjectType.K8S,
    tf: IacProjectType.TERRAFORM,
};


/***/ }),

/***/ 26445:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findDriftCtl = exports.driftctl = exports.parseArgs = exports.driftctlVersion = void 0;
const debugLib = __webpack_require__(15158);
const child_process = __webpack_require__(63129);
const os = __webpack_require__(12087);
const env_paths_1 = __webpack_require__(21766);
const fs = __webpack_require__(35747);
const spinner_1 = __webpack_require__(86766);
const request_1 = __webpack_require__(52050);
const config_1 = __webpack_require__(22541);
const path = __webpack_require__(85622);
const crypto = __webpack_require__(76417);
const cachePath = (_a = config_1.default.CACHE_PATH) !== null && _a !== void 0 ? _a : env_paths_1.default('snyk').cache;
const debug = debugLib('drift');
exports.driftctlVersion = 'v0.19.0';
const driftctlChecksums = {
    'driftctl_windows_386.exe': '0336132cc0c24beaef2535e0a129d146c1a267f6296d5d6bcc7fbe0b02f0bc78',
    driftctl_darwin_amd64: '07eae8f9e537183031bb78203c1c50a0ca80e114716598946b76baadcbca2656',
    driftctl_linux_386: '4b83a5644ce72d3eabd915ffc1bba13ad1d61914984801800f598b35db2fe054',
    driftctl_linux_amd64: '4bfd536e2123667e01b6e5d54acc27733be0db5a00b7fda7f41fabcd9e910e1d',
    driftctl_linux_arm64: '50bbf8f47ec7dcb9cc09a628444b093a0305aa9b4accc84b7c366a2297390881',
    'driftctl_windows_arm64.exe': '6eee390fb97998f309ff0491b893d8727f90f45b98f42fd1aa3ebef29fd7fc5b',
    driftctl_darwin_arm64: '6f37d9f2e385ef81adea9a1f68f2c85f859608dd854416d8ecf629e626bc8b0c',
    'driftctl_windows_arm.exe': '7ce916deaad289f41c874a4ddff41e9e6195cd5f78821a5769f8e66434be5465',
    driftctl_linux_arm: 'a73193472fb33744f0a344a5f3a5663bd0f4791c393a68ea1b4c219b02eda8f1',
    'driftctl_windows_amd64.exe': 'be423648c164f816ea98eae9694aa7c6679d0a6c33305aceb435cd75821bc730',
};
const dctlBaseUrl = 'https://github.com/snyk/driftctl/releases/download/';
const driftctlPath = path.join(cachePath, 'driftctl_' + exports.driftctlVersion);
function parseArgs(commands, options) {
    const args = commands;
    if (options.quiet) {
        args.push('--quiet');
    }
    if (options.filter) {
        args.push('--filter');
        args.push(options.filter);
    }
    if (options.output) {
        args.push('--output');
        args.push(options.output);
    }
    if (options.headers) {
        args.push('--headers');
        args.push(options.headers);
    }
    if (options['tfc-token']) {
        args.push('--tfc-token');
        args.push(options['tfc-token']);
    }
    if (options['tfc-endpoint']) {
        args.push('--tfc-endpoint');
        args.push(options['tfc-endpoint']);
    }
    if (options['tf-provider-version']) {
        args.push('--tf-provider-version');
        args.push(options['tf-provider-version']);
    }
    if (options.strict) {
        args.push('--strict');
    }
    if (options.deep) {
        args.push('--deep');
    }
    if (options.driftignore) {
        args.push('--driftignore');
        args.push(options.driftignore);
    }
    if (options['tf-lockfile']) {
        args.push('--tf-lockfile');
        args.push(options['tf-lockfile']);
    }
    let configDir = cachePath;
    createIfNotExists(cachePath);
    if (options['config-dir']) {
        configDir = options['config-dir'];
    }
    args.push('--config-dir');
    args.push(configDir);
    if (options.from) {
        args.push('--from');
        args.push(options.from);
    }
    let to = 'aws+tf';
    if (options.to) {
        to = options.to;
    }
    args.push('--to');
    args.push(to);
    debug(args);
    return args;
}
exports.parseArgs = parseArgs;
async function driftctl(args) {
    debug('running driftctl %s ', args.join(' '));
    const path = await findOrDownload();
    return await launch(path, args);
}
exports.driftctl = driftctl;
async function launch(path, args) {
    return new Promise((resolve, reject) => {
        const child = child_process.spawn(path, args, { stdio: 'inherit' });
        child.on('error', (error) => {
            reject(error);
        });
        child.on('exit', (code) => {
            if (code == null) {
                //failed to find why this could happen...
                reject(new Error('Process was terminated'));
            }
            else {
                resolve(code);
            }
        });
    });
}
async function findOrDownload() {
    let dctl = await findDriftCtl();
    if (dctl === '') {
        try {
            createIfNotExists(cachePath);
            dctl = driftctlPath;
            await download(driftctlUrl(), dctl);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    return dctl;
}
async function findDriftCtl() {
    // lookup in custom path contained in env var DRIFTCTL_PATH
    let dctlPath = config_1.default.DRIFTCTL_PATH;
    if (dctlPath != null) {
        const exists = await isExe(dctlPath);
        if (exists) {
            debug('Found driftctl in $DRIFTCTL_PATH: %s', dctlPath);
            return dctlPath;
        }
    }
    // lookup in app cache
    dctlPath = driftctlPath;
    const exists = await isExe(dctlPath);
    if (exists) {
        debug('Found driftctl in cache: %s', dctlPath);
        return dctlPath;
    }
    debug('driftctl not found');
    return '';
}
exports.findDriftCtl = findDriftCtl;
async function download(url, destination) {
    debug('downloading driftctl into %s', destination);
    const payload = {
        method: 'GET',
        url: url,
        output: destination,
        follow: 3,
    };
    await spinner_1.spinner('Downloading...');
    return new Promise((resolve, reject) => {
        request_1.makeRequest(payload, function (err, res, body) {
            try {
                if (err) {
                    reject(new Error('Could not download driftctl from ' + url + ': ' + err));
                    return;
                }
                if (res.statusCode !== 200) {
                    reject(new Error('Could not download driftctl from ' + url + ': ' + res.statusCode));
                    return;
                }
                validateChecksum(body);
                fs.writeFileSync(destination, body);
                debug('File saved: ' + destination);
                fs.chmodSync(destination, 0o744);
                resolve(true);
            }
            finally {
                spinner_1.spinner.clearAll();
            }
        });
    });
}
function validateChecksum(body) {
    // only validate if we downloaded the official driftctl binary
    if (config_1.default.DRIFTCTL_URL || config_1.default.DRIFTCTL_PATH) {
        return;
    }
    const computedHash = crypto
        .createHash('sha256')
        .update(body)
        .digest('hex');
    const givenHash = driftctlChecksums[driftctlFileName()];
    if (computedHash != givenHash) {
        throw new Error('Downloaded file has inconsistent checksum...');
    }
}
function driftctlFileName() {
    let platform = 'linux';
    switch (os.platform()) {
        case 'darwin':
            platform = 'darwin';
            break;
        case 'win32':
            platform = 'windows';
            break;
    }
    let arch = 'amd64';
    switch (os.arch()) {
        case 'ia32':
        case 'x32':
            arch = '386';
            break;
        case 'arm':
            arch = 'arm';
            break;
        case 'arm64':
            arch = 'arm64';
            break;
    }
    let ext = '';
    switch (os.platform()) {
        case 'win32':
            ext = '.exe';
            break;
    }
    return `driftctl_${platform}_${arch}${ext}`;
}
function driftctlUrl() {
    if (config_1.default.DRIFTCTL_URL) {
        return config_1.default.DRIFTCTL_URL;
    }
    return `${dctlBaseUrl}/${exports.driftctlVersion}/${driftctlFileName()}`;
}
function isExe(dctlPath) {
    return new Promise((resolve) => {
        fs.access(dctlPath, fs.constants.X_OK, (err) => {
            if (err) {
                resolve(false);
                return;
            }
            resolve(true);
        });
    });
}
function createIfNotExists(path) {
    if (!fs.existsSync(path)) {
        fs.mkdirSync(path, { recursive: true });
    }
}


/***/ }),

/***/ 43458:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeValidateTerraformRequest = exports.validateK8sFile = exports.getFileType = void 0;
//TODO(orka): take out into a new lib
const debugLib = __webpack_require__(15158);
const cloud_config_parser_1 = __webpack_require__(98611);
const errors_1 = __webpack_require__(55191);
const request_1 = __webpack_require__(52050);
const api_token_1 = __webpack_require__(95181);
const config_1 = __webpack_require__(22541);
const debug = debugLib('snyk-detect');
const requiredK8SObjectFields = ['apiVersion', 'kind', 'metadata'];
function getFileType(filePath) {
    const filePathSplit = filePath.split('.');
    return filePathSplit[filePathSplit.length - 1].toLowerCase();
}
exports.getFileType = getFileType;
function parseFileContent(fileContent, filePath) {
    const fileType = getFileType(filePath);
    switch (fileType) {
        case 'yaml':
        case 'yml':
        case 'json':
            try {
                return cloud_config_parser_1.parseFileContent(fileContent);
            }
            catch (e) {
                if (fileType === 'json') {
                    debug('Failed to parse iac config as a JSON');
                }
                else {
                    debug('Failed to parse iac config as a YAML');
                }
            }
            break;
        default:
            debug(`Unsupported iac config file type (${fileType})`);
    }
    return undefined;
}
// This function validates that there is at least one valid doc with a k8s object kind.
// If there is a doc with a supported kind, but invalid, we should fail
// The function return true if the yaml is a valid k8s one, or false otherwise
function validateK8sFile(fileContent, filePath, fileName) {
    const k8sObjects = parseFileContent(fileContent, filePath);
    if (!k8sObjects) {
        return { isValidFile: false, reason: errors_1.IllegalIacFileErrorMsg(fileName) };
    }
    let numOfSupportedKeyDocs = 0;
    for (let i = 0; i < k8sObjects.length; i++) {
        const k8sObject = k8sObjects[i];
        if (!k8sObject || !k8sObject.kind) {
            continue;
        }
        numOfSupportedKeyDocs++;
        for (const key of requiredK8SObjectFields) {
            if (!k8sObject[key]) {
                debug(`Missing required field (${key})`);
                return {
                    isValidFile: false,
                    reason: errors_1.IllegalIacFileErrorMsg(fileName),
                };
            }
        }
    }
    if (numOfSupportedKeyDocs === 0) {
        return {
            isValidFile: false,
            reason: errors_1.NotSupportedIacFileErrorMsg(fileName),
        };
    }
    debug(`k8s config found (${filePath})`);
    return { isValidFile: true, reason: '' };
}
exports.validateK8sFile = validateK8sFile;
async function makeValidateTerraformRequest(terraformFileContent) {
    var _a, _b;
    const response = await request_1.makeRequest({
        body: {
            contentBase64: Buffer.from(terraformFileContent).toString('base64'),
        },
        url: `${config_1.default.API}/iac-validate/terraform`,
        method: 'POST',
        json: true,
        headers: {
            Authorization: `token ${api_token_1.api()}`,
        },
    });
    // Token may have expired, so we need to ask the client to re-auth.
    if (response.res.statusCode === 401) {
        throw new errors_1.MissingApiTokenError();
    }
    if (!response.res.statusCode ||
        (response.res.statusCode < 200 && response.res.statusCode >= 300)) {
        debug(`internal server error - ${response.body}`);
        throw new errors_1.InternalServerError('Error occurred validating terraform file');
    }
    const { body } = response;
    return {
        isValidFile: (_a = body === null || body === void 0 ? void 0 : body.isValidTerraformFile) !== null && _a !== void 0 ? _a : false,
        reason: (_b = body === null || body === void 0 ? void 0 : body.reason) !== null && _b !== void 0 ? _b : '',
    };
}
exports.makeValidateTerraformRequest = makeValidateTerraformRequest;


/***/ }),

/***/ 87491:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeDirectoryIterator = void 0;
const fs = __webpack_require__(35747);
const path_1 = __webpack_require__(85622);
/**
 * Walk the provided directory tree, depth first, yielding the matched filename
 * to the caller. An optional `maxDepth` argument can be provided to limit how
 * deep in the file tree the search will go.
 */
function* makeDirectoryIterator(root, options = {}) {
    if (!isDirectory(root)) {
        throw new Error(`Path "${root}" is not a directory`);
    }
    // Internal function to allow us to track the recursion depth.
    function* walk(dirpath, currentDepth) {
        const filenames = fs.readdirSync(dirpath);
        for (const filename of filenames) {
            // NOTE: We filter filenames that start with a period to maintain
            // backwards compatibility with the original implementation that used the
            // "glob" package.
            if (!options.includeDotfiles && filename.startsWith('.')) {
                continue;
            }
            const resolved = path_1.resolve(dirpath, filename);
            if (isDirectory(resolved)) {
                // Skip this directory if max depth has been reached.
                if (options.maxDepth === currentDepth) {
                    continue;
                }
                yield* walk(resolved, currentDepth + 1);
            }
            else {
                yield resolved;
            }
        }
    }
    yield* walk(root, 1);
}
exports.makeDirectoryIterator = makeDirectoryIterator;
// NOTE: We use isDirectory here instead of isLocalFolder() in order to
// follow symlinks and match the original glob() implementation.
function isDirectory(path) {
    try {
        // statSync will resolve symlinks, lstatSync will not.
        return fs.statSync(path).isDirectory();
    }
    catch (e) {
        return false;
    }
}


/***/ }),

/***/ 8820:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findAndLoadPolicy = void 0;
const snykPolicyLib = __webpack_require__(70535);
const debugModule = __webpack_require__(15158);
const _1 = __webpack_require__(32615);
const analytics = __webpack_require__(82744);
const debug = debugModule('snyk');
async function findAndLoadPolicy(root, scanType, options, pkg, scannedProjectFolder) {
    const isDocker = scanType === 'docker';
    const isNodeProject = ['npm', 'yarn'].includes(scanType);
    // monitor
    let policyLocations = [
        options['policy-path'] || scannedProjectFolder || root,
    ];
    if (isDocker) {
        policyLocations = policyLocations.filter((loc) => loc !== root);
    }
    else if (isNodeProject) {
        // TODO: pluckPolicies expects a package.json object to
        // find and apply policies in node_modules
        policyLocations = policyLocations.concat(_1.pluckPolicies(pkg));
    }
    debug('Potential policy locations found:', policyLocations);
    analytics.add('policies', policyLocations.length);
    analytics.add('policyLocations', policyLocations);
    if (policyLocations.length === 0) {
        return;
    }
    let policy;
    try {
        policy = await snykPolicyLib.load(policyLocations, options);
    }
    catch (err) {
        // note: inline catch, to handle error from .load
        // if the .snyk file wasn't found, it is fine
        if (err.code !== 'ENOENT' && err.code !== 'ENOTDIR') {
            throw err;
        }
    }
    return policy;
}
exports.findAndLoadPolicy = findAndLoadPolicy;


/***/ }),

/***/ 32615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var pluck_policies_1 = __webpack_require__(68247);
Object.defineProperty(exports, "pluckPolicies", ({ enumerable: true, get: function () { return pluck_policies_1.pluckPolicies; } }));
var find_and_load_policy_1 = __webpack_require__(8820);
Object.defineProperty(exports, "findAndLoadPolicy", ({ enumerable: true, get: function () { return find_and_load_policy_1.findAndLoadPolicy; } }));


/***/ }),

/***/ 68247:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pluckPolicies = void 0;
const flatten = __webpack_require__(5800);
function pluckPolicies(pkg) {
    if (!pkg) {
        return [];
    }
    if (pkg.snyk) {
        return pkg.snyk;
    }
    if (!pkg.dependencies) {
        return [];
    }
    return flatten(Object.keys(pkg.dependencies)
        .map((name) => pluckPolicies(pkg.dependencies[name]))
        .filter(Boolean));
}
exports.pluckPolicies = pluckPolicies;


/***/ })

};
;
//# sourceMappingURL=756.index.js.map